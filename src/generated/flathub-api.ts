/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * Flathub API
 * OpenAPI spec version: 0.1.0
 */
export type AddonAppstreamReleases = Release[] | null;

export type AddonAppstreamContentRating = ContentRating | null;

export type AddonAppstreamUrls = Urls | null;

export type AddonAppstreamCategories = string[] | null;

export type AddonAppstreamIcon = string | null;

export type AddonAppstreamIcons = Icon[] | null;

export type AddonAppstreamDeveloperName = string | null;

export type AddonAppstreamProjectLicense = string | null;

export type AddonAppstreamMetadata = Metadata | null;

export type AddonAppstreamIsMobileFriendly = boolean | null;

/**
 * Addon Appstream metadata
 */
export interface AddonAppstream {
  type: 'addon';
  id: string;
  name: string;
  summary: string;
  releases?: AddonAppstreamReleases;
  content_rating?: AddonAppstreamContentRating;
  urls?: AddonAppstreamUrls;
  categories?: AddonAppstreamCategories;
  icon?: AddonAppstreamIcon;
  icons?: AddonAppstreamIcons;
  developer_name?: AddonAppstreamDeveloperName;
  project_license?: AddonAppstreamProjectLicense;
  extends: string;
  bundle: Bundle;
  metadata?: AddonAppstreamMetadata;
  isMobileFriendly?: AddonAppstreamIsMobileFriendly;
  is_free_license: boolean;
}

export interface AppOfTheDay {
  app_id: string;
  day: string;
}

export interface AppOfTheWeek {
  app_id: string;
  position: number;
  isFullscreen: boolean;
}

export type AppPickRecommendationLastTimeAppOfTheWeek = string | null;

export type AppPickRecommendationLastTimeAppOfTheDay = string | null;

export interface AppPickRecommendation {
  app_id: string;
  numberOfTimesAppOfTheWeek: number;
  lastTimeAppOfTheWeek: AppPickRecommendationLastTimeAppOfTheWeek;
  numberOfTimesAppOfTheDay: number;
  lastTimeAppOfTheDay: AppPickRecommendationLastTimeAppOfTheDay;
}

export interface AppPickRecommendationsResponse {
  recommendations: AppPickRecommendation[];
}

export type AppType = typeof AppType[keyof typeof AppType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AppType = {
  apps: 'apps',
  desktop: 'desktop',
  'desktop-application': 'desktop-application',
  'console-application': 'console-application',
  localization: 'localization',
  generic: 'generic',
  extension: 'extension',
  addon: 'addon',
  runtime: 'runtime',
} as const;

export type AppsIndexKeywords = string[] | null;

export type AppsIndexTranslationsAnyOf = {[key: string]: {[key: string]: string | string[]}};

export type AppsIndexTranslations = AppsIndexTranslationsAnyOf | null;

export type AppsIndexIcon = string | null;

export type AppsIndexMainCategories = MainCategory | MainCategory[];

export type AppsIndexSubCategories = string[] | null;

export type AppsIndexDeveloperName = string | null;

export type AppsIndexVerificationLoginName = string | null;

export type AppsIndexVerificationLoginProvider = ConnectedAccountProvider | null;

export type AppsIndexVerificationLoginIsOrganization = boolean | null;

export type AppsIndexVerificationWebsite = string | null;

export type AppsIndexVerificationTimestamp = string | null;

export type AppsIndexRuntime = string | null;

export type AppsIndexArches = string[] | null;

export type AppsIndexAddedAt = number | null;

export type AppsIndexTrending = number | null;

export type AppsIndexInstallsLastMonth = number | null;

export type AppsIndexFavoritesCount = number | null;

export interface AppsIndex {
  name: string;
  keywords: AppsIndexKeywords;
  summary: string;
  description: string;
  id: string;
  type: string;
  translations?: AppsIndexTranslations;
  project_license: string;
  is_free_license: boolean;
  app_id: string;
  icon: AppsIndexIcon;
  main_categories: AppsIndexMainCategories;
  sub_categories?: AppsIndexSubCategories;
  developer_name: AppsIndexDeveloperName;
  verification_verified: boolean;
  verification_method: VerificationMethod;
  verification_login_name: AppsIndexVerificationLoginName;
  verification_login_provider: AppsIndexVerificationLoginProvider;
  verification_login_is_organization: AppsIndexVerificationLoginIsOrganization;
  verification_website: AppsIndexVerificationWebsite;
  verification_timestamp: AppsIndexVerificationTimestamp;
  runtime: AppsIndexRuntime;
  updated_at: number;
  arches: AppsIndexArches;
  added_at?: AppsIndexAddedAt;
  trending?: AppsIndexTrending;
  installs_last_month?: AppsIndexInstallsLastMonth;
  favorites_count?: AppsIndexFavoritesCount;
  isMobileFriendly: boolean;
}

export interface AppsOfTheWeek {
  apps: AppOfTheWeek[];
}

export type ArchiveRequestEndoflifeRebase = string | null;

export interface ArchiveRequest {
  endoflife: string;
  endoflife_rebase?: ArchiveRequestEndoflifeRebase;
}

export type AuthInfoAvatar = string | null;

export interface AuthInfo {
  login: string;
  avatar?: AuthInfoAvatar;
}

export type AuthsGithub = AuthInfo | null;

export type AuthsGitlab = AuthInfo | null;

export type AuthsGnome = AuthInfo | null;

export type AuthsKde = AuthInfo | null;

export interface Auths {
  github?: AuthsGithub;
  gitlab?: AuthsGitlab;
  gnome?: AuthsGnome;
  kde?: AuthsKde;
}

export type AvailableLoginMethodStatus = typeof AvailableLoginMethodStatus[keyof typeof AvailableLoginMethodStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AvailableLoginMethodStatus = {
  ready: 'ready',
  user_does_not_exist: 'user_does_not_exist',
  username_does_not_match: 'username_does_not_match',
  provider_denied_access: 'provider_denied_access',
  not_logged_in: 'not_logged_in',
  not_org_member: 'not_org_member',
  not_org_admin: 'not_org_admin',
} as const;

export type AvailableMethodWebsite = string | null;

export type AvailableMethodWebsiteToken = string | null;

export type AvailableMethodLoginProvider = LoginProvider | null;

export type AvailableMethodLoginName = string | null;

export type AvailableMethodLoginIsOrganization = boolean | null;

export type AvailableMethodLoginStatus = AvailableLoginMethodStatus | null;

export interface AvailableMethod {
  method: AvailableMethodType;
  website?: AvailableMethodWebsite;
  website_token?: AvailableMethodWebsiteToken;
  login_provider?: AvailableMethodLoginProvider;
  login_name?: AvailableMethodLoginName;
  login_is_organization?: AvailableMethodLoginIsOrganization;
  login_status?: AvailableMethodLoginStatus;
}

export type AvailableMethodType = typeof AvailableMethodType[keyof typeof AvailableMethodType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AvailableMethodType = {
  website: 'website',
  login_provider: 'login_provider',
} as const;

export type AvailableMethodsMethods = AvailableMethod[] | null;

export type AvailableMethodsDetail = string | null;

export interface AvailableMethods {
  methods?: AvailableMethodsMethods;
  detail?: AvailableMethodsDetail;
}

export interface BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost {
  appids: string[];
  update_token?: string;
}

export type BrandingSchemePreference = 'light' | 'dark' | null;

/**
 * Branding color information.
 */
export interface Branding {
  value: string;
  scheme_preference?: BrandingSchemePreference;
  type: 'primary';
}

export interface BuildNotificationRequest {
  app_id: string;
  build_id: number;
  build_repo: string;
  diagnostics: unknown[];
}

export type BundleRuntime = string | null;

export type BundleSdk = string | null;

/**
 * Bundle information.
 */
export interface Bundle {
  value: string;
  type: string;
  runtime?: BundleRuntime;
  sdk?: BundleSdk;
}

export interface CheckPurchasesResponseSuccess {
  status?: string;
}

export type ConnectedAccountProvider = typeof ConnectedAccountProvider[keyof typeof ConnectedAccountProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectedAccountProvider = {
  github: 'github',
  gitlab: 'gitlab',
  gnome: 'gnome',
  google: 'google',
  kde: 'kde',
} as const;

export type ContentRatingType = string | null;

export type ContentRatingViolenceCartoon = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceFantasy = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceRealistic = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceBloodshed = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceSexual = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceDesecration = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceSlavery = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingViolenceWorship = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingDrugsAlcohol = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingDrugsNarcotics = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingDrugsTobacco = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexNudity = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexThemes = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexHomosexuality = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexProstitution = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexAdultery = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSexAppearance = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingLanguageProfanity = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingLanguageHumor = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingLanguageDiscrimination = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSocialChat = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSocialInfo = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSocialAudio = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSocialLocation = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingSocialContacts = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingMoneyPurchasing = 'none' | 'mild' | 'moderate' | 'intense' | null;

export type ContentRatingMoneyGambling = 'none' | 'mild' | 'moderate' | 'intense' | null;

/**
 * Content rating information.
 */
export interface ContentRating {
  type?: ContentRatingType;
  violence_cartoon?: ContentRatingViolenceCartoon;
  violence_fantasy?: ContentRatingViolenceFantasy;
  violence_realistic?: ContentRatingViolenceRealistic;
  violence_bloodshed?: ContentRatingViolenceBloodshed;
  violence_sexual?: ContentRatingViolenceSexual;
  violence_desecration?: ContentRatingViolenceDesecration;
  violence_slavery?: ContentRatingViolenceSlavery;
  violence_worship?: ContentRatingViolenceWorship;
  drugs_alcohol?: ContentRatingDrugsAlcohol;
  drugs_narcotics?: ContentRatingDrugsNarcotics;
  drugs_tobacco?: ContentRatingDrugsTobacco;
  sex_nudity?: ContentRatingSexNudity;
  sex_themes?: ContentRatingSexThemes;
  sex_homosexuality?: ContentRatingSexHomosexuality;
  sex_prostitution?: ContentRatingSexProstitution;
  sex_adultery?: ContentRatingSexAdultery;
  sex_appearance?: ContentRatingSexAppearance;
  language_profanity?: ContentRatingLanguageProfanity;
  language_humor?: ContentRatingLanguageHumor;
  language_discrimination?: ContentRatingLanguageDiscrimination;
  social_chat?: ContentRatingSocialChat;
  social_info?: ContentRatingSocialInfo;
  social_audio?: ContentRatingSocialAudio;
  social_location?: ContentRatingSocialLocation;
  social_contacts?: ContentRatingSocialContacts;
  money_purchasing?: ContentRatingMoneyPurchasing;
  money_gambling?: ContentRatingMoneyGambling;
}

export type DeleteUserResultMessage = string | null;

export interface DeleteUserResult {
  status: string;
  message?: DeleteUserResultMessage;
}

export type DesktopAppstreamType = typeof DesktopAppstreamType[keyof typeof DesktopAppstreamType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DesktopAppstreamType = {
  'desktop-application': 'desktop-application',
  'console-application': 'console-application',
  desktop: 'desktop',
} as const;

export type DesktopAppstreamDeveloperName = string | null;

export type DesktopAppstreamIcon = string | null;

export type DesktopAppstreamIcons = Icon[] | null;

export type DesktopAppstreamScreenshots = Screenshot[] | null;

export type DesktopAppstreamContentRating = ContentRating | null;

export type DesktopAppstreamUrls = Urls | null;

export type DesktopAppstreamCategories = string[] | null;

export type DesktopAppstreamKudos = string[] | null;

export type DesktopAppstreamKeywords = string[] | null;

export type DesktopAppstreamMimetypes = string[] | null;

export type DesktopAppstreamProjectLicense = string | null;

export type DesktopAppstreamProvidesAnyOfItem = Provides | string;

export type DesktopAppstreamProvides = DesktopAppstreamProvidesAnyOfItem[] | null;

export type DesktopAppstreamLaunchable = Launchable | null;

export type DesktopAppstreamTranslation = Translation | null;

export type DesktopAppstreamMetadata = Metadata | null;

export type DesktopAppstreamIsMobileFriendly = boolean | null;

export type DesktopAppstreamBranding = Branding[] | null;

/**
 * Desktop application Appstream metadata, matching frontend DesktopAppstream type.
 */
export interface DesktopAppstream {
  type: DesktopAppstreamType;
  id: string;
  name: string;
  summary: string;
  description: string;
  developer_name?: DesktopAppstreamDeveloperName;
  icon?: DesktopAppstreamIcon;
  icons?: DesktopAppstreamIcons;
  screenshots?: DesktopAppstreamScreenshots;
  releases: Release[];
  content_rating?: DesktopAppstreamContentRating;
  urls?: DesktopAppstreamUrls;
  categories?: DesktopAppstreamCategories;
  kudos?: DesktopAppstreamKudos;
  keywords?: DesktopAppstreamKeywords;
  mimetypes?: DesktopAppstreamMimetypes;
  project_license?: DesktopAppstreamProjectLicense;
  provides?: DesktopAppstreamProvides;
  launchable?: DesktopAppstreamLaunchable;
  bundle: Bundle;
  translation?: DesktopAppstreamTranslation;
  metadata?: DesktopAppstreamMetadata;
  is_free_license: boolean;
  isMobileFriendly?: DesktopAppstreamIsMobileFriendly;
  branding?: DesktopAppstreamBranding;
}

export type DeveloperName = string | null;

export type DeveloperIsPrimary = boolean | null;

export interface Developer {
  id: number;
  is_self: boolean;
  name: DeveloperName;
  is_primary?: DeveloperIsPrimary;
}

export type ErrorDetail = typeof ErrorDetail[keyof typeof ErrorDetail];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorDetail = {
  malformed_app_id: 'malformed_app_id',
  not_app_developer: 'not_app_developer',
  invalid_method: 'invalid_method',
  failed_to_connect: 'failed_to_connect',
  server_returned_error: 'server_returned_error',
  app_not_listed: 'app_not_listed',
  blocked_by_admins: 'blocked_by_admins',
  not_logged_in: 'not_logged_in',
  username_does_not_match: 'username_does_not_match',
  user_does_not_exist: 'user_does_not_exist',
  provider_error: 'provider_error',
  provider_denied_access: 'provider_denied_access',
  not_org_member: 'not_org_member',
  not_org_admin: 'not_org_admin',
  app_already_verified: 'app_already_verified',
  must_set_up_first: 'must_set_up_first',
  app_already_exists: 'app_already_exists',
  must_accept_publisher_agreement: 'must_accept_publisher_agreement',
  flat_manager_not_configured: 'flat_manager_not_configured',
} as const;

export interface ErrorReturn {
  detail: ErrorDetail;
}

export interface FailedByGuideline {
  guideline_id: string;
  not_passed: number;
}

export interface FavoriteApp {
  app_id: string;
  created_at: string;
}

export interface Filter {
  filterType: string;
  value: string;
}

export interface FlathubUsersResult {
  users: UserResult[];
  pagination: Pagination;
}

export interface GenerateUpdateTokenResponse {
  token: string;
}

export type GenericAppstreamReleases = Release[] | null;

export type GenericAppstreamCategories = string[] | null;

export type GenericAppstreamIcon = string | null;

export type GenericAppstreamIcons = Icon[] | null;

export type GenericAppstreamDeveloperName = string | null;

export type GenericAppstreamProjectLicense = string | null;

export type GenericAppstreamMetadata = Metadata | null;

export type GenericAppstreamIsMobileFriendly = boolean | null;

/**
 * Generic Appstream metadata
 */
export interface GenericAppstream {
  type: 'generic';
  id: string;
  name: string;
  summary: string;
  releases?: GenericAppstreamReleases;
  urls: Urls;
  categories?: GenericAppstreamCategories;
  icon?: GenericAppstreamIcon;
  icons?: GenericAppstreamIcons;
  developer_name?: GenericAppstreamDeveloperName;
  project_license?: GenericAppstreamProjectLicense;
  bundle: Bundle;
  metadata?: GenericAppstreamMetadata;
  isMobileFriendly?: GenericAppstreamIsMobileFriendly;
  is_free_license: boolean;
}

export interface GetDeleteUserResult {
  status: string;
  token: string;
}

export interface GetDownloadTokenResponse {
  token: string;
  update_token: string;
}

export type GithubAccountResultAvatarUrl = string | null;

export type GithubAccountResultDisplayName = string | null;

export type GithubAccountResultEmail = string | null;

export type GithubAccountResultLastUsed = string | null;

export interface GithubAccountResult {
  provider: ConnectedAccountProvider;
  id: number;
  github_userid: number;
  login: string;
  avatar_url: GithubAccountResultAvatarUrl;
  display_name: GithubAccountResultDisplayName;
  email: GithubAccountResultEmail;
  last_used: GithubAccountResultLastUsed;
}

export interface GithubRepositoryResult {
  id: number;
  reponame: string;
}

export type GitlabAccountResultAvatarUrl = string | null;

export type GitlabAccountResultDisplayName = string | null;

export type GitlabAccountResultEmail = string | null;

export type GitlabAccountResultLastUsed = string | null;

export interface GitlabAccountResult {
  provider: ConnectedAccountProvider;
  id: number;
  gitlab_userid: number;
  login: string;
  avatar_url: GitlabAccountResultAvatarUrl;
  display_name: GitlabAccountResultDisplayName;
  email: GitlabAccountResultEmail;
  last_used: GitlabAccountResultLastUsed;
}

export type GnomeAccountResultAvatarUrl = string | null;

export type GnomeAccountResultDisplayName = string | null;

export type GnomeAccountResultEmail = string | null;

export type GnomeAccountResultLastUsed = string | null;

export interface GnomeAccountResult {
  provider: ConnectedAccountProvider;
  id: number;
  gnome_userid: number;
  login: string;
  avatar_url: GnomeAccountResultAvatarUrl;
  display_name: GnomeAccountResultDisplayName;
  email: GnomeAccountResultEmail;
  last_used: GnomeAccountResultLastUsed;
}

export type GoogleAccountResultAvatarUrl = string | null;

export type GoogleAccountResultDisplayName = string | null;

export type GoogleAccountResultEmail = string | null;

export type GoogleAccountResultLastUsed = string | null;

export interface GoogleAccountResult {
  provider: ConnectedAccountProvider;
  id: number;
  google_userid: number;
  login: string;
  avatar_url: GoogleAccountResultAvatarUrl;
  display_name: GoogleAccountResultDisplayName;
  email: GoogleAccountResultEmail;
  last_used: GoogleAccountResultLastUsed;
}

export interface Guideline {
  id: string;
  url: string;
  needed_to_pass_since: string;
  category: string;
  read_only?: boolean;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type IconUrl = string | null;

export type IconWidth = number | null;

export type IconHeight = number | null;

export type IconScale = number | null;

export type IconType = 'remote' | 'cached' | null;

/**
 * Icon information with different sizes.
 */
export interface Icon {
  url?: IconUrl;
  width?: IconWidth;
  height?: IconHeight;
  scale?: IconScale;
  type?: IconType;
}

export interface InviteStatus {
  is_pending: boolean;
  is_direct_upload_app?: boolean;
}

export type KdeAccountResultAvatarUrl = string | null;

export type KdeAccountResultDisplayName = string | null;

export type KdeAccountResultEmail = string | null;

export type KdeAccountResultLastUsed = string | null;

export interface KdeAccountResult {
  provider: ConnectedAccountProvider;
  id: number;
  kde_userid: number;
  login: string;
  avatar_url: KdeAccountResultAvatarUrl;
  display_name: KdeAccountResultDisplayName;
  email: KdeAccountResultEmail;
  last_used: KdeAccountResultLastUsed;
}

/**
 * Launchable information.
 */
export interface Launchable {
  value: string;
  type: string;
}

export interface LinkResponse {
  link: string;
}

export type LocalizationAppstreamReleases = Release[] | null;

export type LocalizationAppstreamCategories = string[] | null;

export type LocalizationAppstreamIcon = string | null;

export type LocalizationAppstreamIcons = Icon[] | null;

export type LocalizationAppstreamDeveloperName = string | null;

export type LocalizationAppstreamProjectLicense = string | null;

export type LocalizationAppstreamMetadata = Metadata | null;

export type LocalizationAppstreamIsMobileFriendly = boolean | null;

/**
 * Localization Appstream metadata
 */
export interface LocalizationAppstream {
  type: 'localization';
  id: string;
  name: string;
  summary: string;
  releases?: LocalizationAppstreamReleases;
  urls: Urls;
  categories?: LocalizationAppstreamCategories;
  icon?: LocalizationAppstreamIcon;
  icons?: LocalizationAppstreamIcons;
  developer_name?: LocalizationAppstreamDeveloperName;
  project_license?: LocalizationAppstreamProjectLicense;
  bundle: Bundle;
  metadata?: LocalizationAppstreamMetadata;
  isMobileFriendly?: LocalizationAppstreamIsMobileFriendly;
  is_free_license: boolean;
}

export interface LoginMethod {
  method: string;
  name: string;
}

export type LoginProvider = typeof LoginProvider[keyof typeof LoginProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LoginProvider = {
  github: 'github',
  gitlab: 'gitlab',
  gnome: 'gnome',
  kde: 'kde',
} as const;

export type MainCategory = typeof MainCategory[keyof typeof MainCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MainCategory = {
  audiovideo: 'audiovideo',
  development: 'development',
  education: 'education',
  game: 'game',
  graphics: 'graphics',
  network: 'network',
  office: 'office',
  science: 'science',
  system: 'system',
  utility: 'utility',
} as const;

export type MeilisearchResponseAppsIndexFacetDistributionAnyOf = {[key: string]: {[key: string]: number}};

export type MeilisearchResponseAppsIndexFacetDistribution = MeilisearchResponseAppsIndexFacetDistributionAnyOf | null;

export type MeilisearchResponseAppsIndexFacetStatsAnyOf = {[key: string]: {[key: string]: number}};

export type MeilisearchResponseAppsIndexFacetStats = MeilisearchResponseAppsIndexFacetStatsAnyOf | null;

export interface MeilisearchResponseAppsIndex {
  hits: AppsIndex[];
  query: string;
  processingTimeMs: number;
  hitsPerPage: number;
  page: number;
  totalPages: number;
  totalHits: number;
  facetDistribution?: MeilisearchResponseAppsIndexFacetDistribution;
  facetStats?: MeilisearchResponseAppsIndexFacetStats;
}

export type MetadataFlathubManifest = string | null;

export type MetadataFlathubVerificationVerified = boolean | null;

export type MetadataFlathubVerificationMethod = 'manual' | 'website' | 'login_provider' | 'none' | null;

export type MetadataFlathubVerificationLoginName = string | null;

export type MetadataFlathubVerificationLoginProvider = ConnectedAccountProvider | null;

export type MetadataFlathubVerificationWebsite = string | null;

export type MetadataFlathubVerificationTimestamp = string | null;

export type MetadataFlathubVerificationLoginIsOrganization = boolean | null;

export interface Metadata {
  'flathub::manifest'?: MetadataFlathubManifest;
  'flathub::verification::verified'?: MetadataFlathubVerificationVerified;
  'flathub::verification::method'?: MetadataFlathubVerificationMethod;
  'flathub::verification::login_name'?: MetadataFlathubVerificationLoginName;
  'flathub::verification::login_provider'?: MetadataFlathubVerificationLoginProvider;
  'flathub::verification::website'?: MetadataFlathubVerificationWebsite;
  'flathub::verification::timestamp'?: MetadataFlathubVerificationTimestamp;
  'flathub::verification::login_is_organization'?: MetadataFlathubVerificationLoginIsOrganization;
}

export interface ModerationApp {
  requests: ModerationRequestResponse[];
  requests_count: number;
}

export type ModerationAppItemUpdatedAt = string | null;

export interface ModerationAppItem {
  appid: string;
  is_new_submission: boolean;
  updated_at?: ModerationAppItemUpdatedAt;
  request_types: ModerationRequestType[];
}

export interface ModerationAppsResponse {
  apps: ModerationAppItem[];
  apps_count: number;
}

export type ModerationRequestResponseRequestData = RequestData | null;

export type ModerationRequestResponseHandledBy = string | null;

export type ModerationRequestResponseHandledAt = string | null;

export type ModerationRequestResponseIsApproved = boolean | null;

export type ModerationRequestResponseComment = string | null;

export interface ModerationRequestResponse {
  id: number;
  app_id: string;
  created_at: string;
  build_id: number;
  job_id: number;
  is_outdated: boolean;
  request_type: ModerationRequestType;
  request_data?: ModerationRequestResponseRequestData;
  is_new_submission: boolean;
  handled_by?: ModerationRequestResponseHandledBy;
  handled_at?: ModerationRequestResponseHandledAt;
  is_approved?: ModerationRequestResponseIsApproved;
  comment?: ModerationRequestResponseComment;
}

export type ModerationRequestType = typeof ModerationRequestType[keyof typeof ModerationRequestType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModerationRequestType = {
  appdata: 'appdata',
} as const;

export interface NascentTransaction {
  summary: NascentTransactionSummary;
  details: TransactionRow[];
}

export type NascentTransactionSummaryKind = typeof NascentTransactionSummaryKind[keyof typeof NascentTransactionSummaryKind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NascentTransactionSummaryKind = {
  donation: 'donation',
  purchase: 'purchase',
} as const;

export interface NascentTransactionSummary {
  value: number;
  currency: string;
  kind: NascentTransactionSummaryKind;
}

export interface NewTokenResponse {
  token: string;
  details: TokenResponse;
}

export type OauthLoginResponseFailureErrorDescription = string | null;

export type OauthLoginResponseFailureErrorUri = string | null;

export interface OauthLoginResponseFailure {
  state: string;
  error: string;
  error_description?: OauthLoginResponseFailureErrorDescription;
  error_uri?: OauthLoginResponseFailureErrorUri;
}

export interface OauthLoginResponseSuccess {
  code: string;
  state: string;
}

export interface Pagination {
  page: number;
  page_size: number;
  total: number;
  total_pages: number;
}

export interface PaymentCardInfo {
  id: string;
  brand: string;
  country: string;
  exp_month: number;
  exp_year: number;
  last4: string;
}

export type Permission = typeof Permission[keyof typeof Permission];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Permission = {
  'quality-moderation': 'quality-moderation',
  moderation: 'moderation',
  payment: 'payment',
  'direct-upload': 'direct-upload',
  'view-users': 'view-users',
  'modify-users': 'modify-users',
} as const;

export type PlatformDepends = string | null;

export type PlatformStripeAccount = string | null;

/**
 * A platform is an expression of dependencies which an application may have.
Applications nominally express a single platform key for themselves, or
none at all if they do not need one.  But platforms may depend on one another.

If no platform is specified for an application, it's worth getting the default
platform and using that.
 */
export interface Platform {
  depends?: PlatformDepends;
  aliases: string[];
  keep: number;
  stripe_account?: PlatformStripeAccount;
}

export interface PostTransactionResponse {
  status: string;
  id: string;
}

export type PricingInfoRecommendedDonation = number | null;

export type PricingInfoMinimumPayment = number | null;

export interface PricingInfo {
  recommended_donation?: PricingInfoRecommendedDonation;
  minimum_payment?: PricingInfoMinimumPayment;
}

/**
 * Proposed payment to be made for an application
 */
export interface ProposedPayment {
  currency: string;
  amount: number;
}

/**
 * Provides information - what the app provides to the system.
 */
export interface Provides {
  value: string;
  type: string;
}

export interface QualityModerationDashboardResponse {
  apps: QualityModerationDashboardRow[];
  pagination: Pagination;
}

export type QualityModerationDashboardRowAppstream = unknown | null;

export type QualityModerationDashboardRowInstallsLast7Days = number | null;

export interface QualityModerationDashboardRow {
  id: string;
  quality_moderation_status: QualityModerationStatus;
  appstream?: QualityModerationDashboardRowAppstream;
  installs_last_7_days?: QualityModerationDashboardRowInstallsLast7Days;
}

export type QualityModerationResponseReviewRequestedAt = string | null;

export interface QualityModerationResponse {
  guidelines: QualityModerationType[];
  is_fullscreen_app: boolean;
  review_requested_at?: QualityModerationResponseReviewRequestedAt;
}

export type QualityModerationStatusLastUpdated = string | null;

export type QualityModerationStatusReviewRequestedAt = string | null;

export interface QualityModerationStatus {
  passes: boolean;
  unrated: number;
  passed: number;
  not_passed: number;
  last_updated: QualityModerationStatusLastUpdated;
  review_requested_at?: QualityModerationStatusReviewRequestedAt;
}

export type QualityModerationTypeUpdatedBy = number | null;

export type QualityModerationTypePassed = boolean | null;

export type QualityModerationTypeComment = string | null;

export interface QualityModerationType {
  guideline_id: string;
  guideline: Guideline;
  app_id: string;
  updated_at: string;
  updated_by: QualityModerationTypeUpdatedBy;
  passed: QualityModerationTypePassed;
  comment: QualityModerationTypeComment;
  needed_to_pass_since: string;
}

export interface RedemptionResult {
  status: string;
  reason: string;
}

export interface RefreshDevFlatpaksReturn {
  dev_flatpaks: string[];
}

export type ReleaseTimestamp = string | null;

export type ReleaseVersion = string | null;

export type ReleaseDate = string | null;

export type ReleaseType = 'stable' | 'development' | 'snapshot' | null;

export type ReleaseUrgency = 'low' | 'medium' | 'high' | 'critical' | null;

export type ReleaseDescription = string | null;

export type ReleaseUrl = string | null;

export type ReleaseDateEol = string | null;

/**
 * A release/version entry.
 */
export interface Release {
  timestamp?: ReleaseTimestamp;
  version?: ReleaseVersion;
  date?: ReleaseDate;
  type?: ReleaseType;
  urgency?: ReleaseUrgency;
  description?: ReleaseDescription;
  url?: ReleaseUrl;
  date_eol?: ReleaseDateEol;
}

export type RequestDataKeysAnyOf = { [key: string]: unknown };

export type RequestDataKeys = {[key: string]: string | unknown[] | RequestDataKeysAnyOf | boolean | null};

export type RequestDataCurrentValuesAnyOf = { [key: string]: unknown };

export type RequestDataCurrentValues = {[key: string]: string | unknown[] | RequestDataCurrentValuesAnyOf | boolean | null};

export interface RequestData {
  keys: RequestDataKeys;
  current_values: RequestDataCurrentValues;
}

export type ReviewComment = string | null;

export interface Review {
  approve: boolean;
  comment?: ReviewComment;
}

export interface ReviewRequest {
  build_id: number;
  job_id: number;
}

export interface ReviewRequestResponse {
  requires_review: boolean;
}

export interface ReviewResponse {
  github_issue_url: string;
}

export type RoleName = typeof RoleName[keyof typeof RoleName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoleName = {
  admin: 'admin',
  moderator: 'moderator',
  'quality-moderator': 'quality-moderator',
  uploader: 'uploader',
} as const;

export type RuntimeAppstreamDescription = string | null;

export type RuntimeAppstreamReleases = Release[] | null;

export type RuntimeAppstreamCategories = string[] | null;

export type RuntimeAppstreamIcon = string | null;

export type RuntimeAppstreamIcons = Icon[] | null;

export type RuntimeAppstreamDeveloperName = string | null;

export type RuntimeAppstreamProjectLicense = string | null;

export type RuntimeAppstreamMetadata = Metadata | null;

export type RuntimeAppstreamIsMobileFriendly = boolean | null;

/**
 * Runtime Appstream metadata
 */
export interface RuntimeAppstream {
  type: 'runtime';
  id: string;
  name: string;
  summary: string;
  description?: RuntimeAppstreamDescription;
  releases?: RuntimeAppstreamReleases;
  urls: Urls;
  categories?: RuntimeAppstreamCategories;
  icon?: RuntimeAppstreamIcon;
  icons?: RuntimeAppstreamIcons;
  developer_name?: RuntimeAppstreamDeveloperName;
  project_license?: RuntimeAppstreamProjectLicense;
  bundle: Bundle;
  metadata?: RuntimeAppstreamMetadata;
  isMobileFriendly?: RuntimeAppstreamIsMobileFriendly;
  is_free_license: boolean;
}

export type ScreenshotCaption = string | null;

export type ScreenshotDefault = boolean | null;

/**
 * A screenshot with multiple size variants.
 */
export interface Screenshot {
  sizes: ScreenshotSize[];
  caption?: ScreenshotCaption;
  default?: ScreenshotDefault;
}

/**
 * A single size variant of a screenshot.
 */
export interface ScreenshotSize {
  width: string;
  height: string;
  scale?: string;
  src: string;
}

export type SearchQueryFilters = Filter[] | null;

export interface SearchQuery {
  query: string;
  filters?: SearchQueryFilters;
  hits_per_page?: number;
  page?: number;
}

export interface SimpleQualityModerationResponse {
  apps: string[];
  pagination: Pagination;
}

export type StatsResultTotals = {[key: string]: number};

export type StatsResultCountries = {[key: string]: number};

export type StatsResultDownloadsPerDay = {[key: string]: number};

export type StatsResultUpdatesPerDay = {[key: string]: number};

export type StatsResultDeltaDownloadsPerDay = {[key: string]: number};

export interface StatsResult {
  totals: StatsResultTotals;
  countries: StatsResultCountries;
  downloads_per_day: StatsResultDownloadsPerDay;
  updates_per_day: StatsResultUpdatesPerDay;
  delta_downloads_per_day: StatsResultDeltaDownloadsPerDay;
  category_totals: StatsResultCategoryTotals[];
}

export type StatsResultAppInstallsPerDay = {[key: string]: number};

export type StatsResultAppInstallsPerCountry = {[key: string]: number};

export interface StatsResultApp {
  installs_total: number;
  installs_per_day: StatsResultAppInstallsPerDay;
  installs_per_country: StatsResultAppInstallsPerCountry;
  installs_last_month: number;
  installs_last_7_days: number;
  id: string;
}

export interface StatsResultCategoryTotals {
  category: string;
  count: number;
}

export type StorefrontInfoVerificationAnyOf = VerificationStatusNone | VerificationStatusManual | VerificationStatusWebsite | VerificationStatusLoginProvider;

export type StorefrontInfoVerification = StorefrontInfoVerificationAnyOf | null;

export type StorefrontInfoPricing = PricingInfo | null;

export interface StorefrontInfo {
  verification?: StorefrontInfoVerification;
  pricing?: StorefrontInfoPricing;
  is_free_software?: boolean;
}

export interface StripeKeys {
  status: string;
  public_key: string;
}

export type SummaryExtensionDirectory = string | null;

export type SummaryExtensionAutodelete = string | null;

export type SummaryExtensionNoAutodownload = string | null;

export type SummaryExtensionVersion = string | null;

export type SummaryExtensionVersions = string | null;

/**
 * Extension information.
 */
export interface SummaryExtension {
  directory?: SummaryExtensionDirectory;
  autodelete?: SummaryExtensionAutodelete;
  noAutodownload?: SummaryExtensionNoAutodownload;
  version?: SummaryExtensionVersion;
  versions?: SummaryExtensionVersions;
  [key: string]: unknown;
 }

/**
 * Extra data information.
 */
export interface SummaryExtraData {
  name: string;
  checksum: string;
  size: string;
  uri: string;
}

export type SummaryMetadataSdk = string | null;

export type SummaryMetadataTags = string[] | null;

export type SummaryMetadataCommand = string | null;

export type SummaryMetadataPermissions = SummaryPermissions | null;

export type SummaryMetadataExtensionsAnyOf = {[key: string]: SummaryExtension};

export type SummaryMetadataExtensions = SummaryMetadataExtensionsAnyOf | null;

export type SummaryMetadataBuiltExtensions = string[] | null;

export type SummaryMetadataExtraData = SummaryExtraData | null;

/**
 * Metadata from the Flatpak summary.
 */
export interface SummaryMetadata {
  name: string;
  runtime: string;
  sdk?: SummaryMetadataSdk;
  tags?: SummaryMetadataTags;
  command?: SummaryMetadataCommand;
  permissions?: SummaryMetadataPermissions;
  extensions?: SummaryMetadataExtensions;
  builtExtensions?: SummaryMetadataBuiltExtensions;
  extraData?: SummaryMetadataExtraData;
  runtimeIsEol?: boolean;
  [key: string]: unknown;
 }

export type SummaryPermissionsShared = string[] | null;

export type SummaryPermissionsSockets = string[] | null;

export type SummaryPermissionsDevices = string[] | null;

export type SummaryPermissionsFilesystems = string[] | null;

export type SummaryPermissionsSessionBusAnyOf = {[key: string]: string[]};

export type SummaryPermissionsSessionBus = SummaryPermissionsSessionBusAnyOf | null;

/**
 * Permissions required by the application.
 */
export interface SummaryPermissions {
  shared?: SummaryPermissionsShared;
  sockets?: SummaryPermissionsSockets;
  devices?: SummaryPermissionsDevices;
  filesystems?: SummaryPermissionsFilesystems;
  'session-bus'?: SummaryPermissionsSessionBus;
}

export type SummaryResponseBranch = string | null;

export type SummaryResponseMetadata = SummaryMetadata | null;

/**
 * Summary information response for an application.

This model represents the summary data returned by the /summary/{app_id} endpoint,
containing information about app size, architectures, and metadata.
 */
export interface SummaryResponse {
  arches: string[];
  branch?: SummaryResponseBranch;
  timestamp: number;
  download_size: number;
  installed_size: number;
  metadata?: SummaryResponseMetadata;
  [key: string]: unknown;
 }

export type TokenCancellationStatus = typeof TokenCancellationStatus[keyof typeof TokenCancellationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenCancellationStatus = {
  invalid: 'invalid',
  cancelled: 'cancelled',
  error: 'error',
} as const;

export interface TokenCancellation {
  token: string;
  status: TokenCancellationStatus;
}

export interface TokenList {
  status: string;
  total: number;
  tokens: TokenModel[];
}

export type TokenModelState = typeof TokenModelState[keyof typeof TokenModelState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenModelState = {
  unredeemed: 'unredeemed',
  redeemed: 'redeemed',
  cancelled: 'cancelled',
} as const;

export type TokenModelToken = string | null;

export interface TokenModel {
  id: string;
  state: TokenModelState;
  name: string;
  token?: TokenModelToken;
  created: string;
  changed: string;
}

export type TokenResponseIssuedTo = string | null;

export interface TokenResponse {
  id: number;
  comment: string;
  app_id: string;
  scopes: string[];
  repos: string[];
  issued_at: number;
  issued_to: TokenResponseIssuedTo;
  expires_at: number;
  revoked: boolean;
}

export interface TokensResponse {
  tokens: TokenResponse[];
  is_direct_upload_app: boolean;
}

export type TransactionCard = PaymentCardInfo | null;

export type TransactionReceipt = string | null;

export interface Transaction {
  summary: TransactionSummary;
  card?: TransactionCard;
  details: TransactionRow[];
  receipt?: TransactionReceipt;
}

export type TransactionRowKind = typeof TransactionRowKind[keyof typeof TransactionRowKind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionRowKind = {
  donation: 'donation',
  purchase: 'purchase',
} as const;

export interface TransactionRow {
  recipient: string;
  amount: number;
  currency: string;
  kind: TransactionRowKind;
}

export type TransactionSaveCardSaveCard = 'off_session' | 'on_session' | null;

export interface TransactionSaveCard {
  save_card?: TransactionSaveCardSaveCard;
}

/**
 * Sorting of transactions, either most-recent first, or oldest first
 */
export type TransactionSortOrder = typeof TransactionSortOrder[keyof typeof TransactionSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionSortOrder = {
  recent: 'recent',
  oldest: 'oldest',
} as const;

export type TransactionStripeDataCard = PaymentCardInfo | null;

export interface TransactionStripeData {
  status: string;
  client_secret: string;
  card?: TransactionStripeDataCard;
}

export type TransactionSummaryKind = typeof TransactionSummaryKind[keyof typeof TransactionSummaryKind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionSummaryKind = {
  donation: 'donation',
  purchase: 'purchase',
} as const;

export type TransactionSummaryStatus = typeof TransactionSummaryStatus[keyof typeof TransactionSummaryStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionSummaryStatus = {
  new: 'new',
  retry: 'retry',
  pending: 'pending',
  success: 'success',
  cancelled: 'cancelled',
} as const;

export type TransactionSummaryReason = string | null;

export type TransactionSummaryCreated = number | null;

export type TransactionSummaryUpdated = number | null;

export interface TransactionSummary {
  id: string;
  value: number;
  currency: string;
  kind: TransactionSummaryKind;
  status: TransactionSummaryStatus;
  reason?: TransactionSummaryReason;
  created?: TransactionSummaryCreated;
  updated?: TransactionSummaryUpdated;
}

export type TranslationValue = string | null;

export type TranslationType = string | null;

/**
 * Translation information.
 */
export interface Translation {
  value?: TranslationValue;
  type?: TranslationType;
}

export interface UploadTokenRequest {
  comment: string;
  scopes: string[];
  repos: string[];
}

export interface UpsertAppOfTheWeek {
  app_id: string;
  weekNumber: number;
  year: number;
  position: number;
}

export interface UpsertQualityModeration {
  guideline_id: string;
  passed: boolean;
}

export type UrlsBugtracker = string | null;

export type UrlsHomepage = string | null;

export type UrlsHelp = string | null;

export type UrlsDonation = string | null;

export type UrlsTranslate = string | null;

export type UrlsFaq = string | null;

export type UrlsContact = string | null;

export type UrlsVcsBrowser = string | null;

export type UrlsContribute = string | null;

/**
 * Various URLs related to the app.
 */
export interface Urls {
  bugtracker?: UrlsBugtracker;
  homepage?: UrlsHomepage;
  help?: UrlsHelp;
  donation?: UrlsDonation;
  translate?: UrlsTranslate;
  faq?: UrlsFaq;
  contact?: UrlsContact;
  vcs_browser?: UrlsVcsBrowser;
  contribute?: UrlsContribute;
}

export interface UserDeleteRequest {
  token: string;
}

export type UserInfoDisplayname = string | null;

export type UserInfoAcceptedPublisherAgreementAt = string | null;

export interface UserInfo {
  displayname?: UserInfoDisplayname;
  dev_flatpaks?: string[];
  permissions?: Permission[];
  owned_flatpaks?: string[];
  invited_flatpaks?: string[];
  invite_code: string;
  accepted_publisher_agreement_at: UserInfoAcceptedPublisherAgreementAt;
  default_account: AuthInfo;
  auths: Auths;
}

export interface UserOwnedAppResult {
  app_id: string;
  created: string;
}

export type UserResultDisplayName = string | null;

export type UserResultDefaultAccount = GithubAccountResult | GitlabAccountResult | GnomeAccountResult | GoogleAccountResult | KdeAccountResult | null;

export type UserResultConnectedAccountsItem = GithubAccountResult | GitlabAccountResult | GnomeAccountResult | GoogleAccountResult | KdeAccountResult;

export type UserResultAcceptedPublisherAgreementAt = string | null;

export type UserResultGithubRepos = GithubRepositoryResult[] | null;

export type UserResultOwnedApps = UserOwnedAppResult[] | null;

export interface UserResult {
  id: number;
  display_name: UserResultDisplayName;
  default_account: UserResultDefaultAccount;
  connected_accounts: UserResultConnectedAccountsItem[];
  accepted_publisher_agreement_at: UserResultAcceptedPublisherAgreementAt;
  roles: UserRoleResult[];
  github_repos: UserResultGithubRepos;
  owned_apps: UserResultOwnedApps;
}

export interface UserRoleResult {
  name: string;
  hasRole: boolean;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type VendingApplicationInformationKind = typeof VendingApplicationInformationKind[keyof typeof VendingApplicationInformationKind];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VendingApplicationInformationKind = {
  GAME: 'GAME',
  PRODUCTIVITY: 'PRODUCTIVITY',
  GENERIC: 'GENERIC',
} as const;

/**
 * Information about an app, including tax code etc
 */
export interface VendingApplicationInformation {
  app_id: string;
  kind: VendingApplicationInformationKind;
  kind_reason: string;
  foss: boolean;
  foss_reason: string;
}

export type VendingConfigPlatforms = {[key: string]: Platform};

/**
 * Global vending environment configuration values
 */
export interface VendingConfig {
  status: 'ok';
  platforms: VendingConfigPlatforms;
  fee_fixed_cost: number;
  fee_cost_percent: number;
  fee_prefer_percent: number;
}

/**
 * A request to begin/continue the onboarding process for a user.

Any onboarding operation request a 'return' URL which we will tell Stripe
to send us back to.
 */
export interface VendingOnboardingRequest {
  return_url: string;
}

/**
 * Result from attempting to make a proposed payment
 */
export interface VendingOutput {
  status: string;
  transaction: string;
}

/**
 * Any redirect the vending system needs to create will be returned like this.

Status will be "ok" otherwise you cannot rely on target_url and instead
something look for like error.
 */
export interface VendingRedirect {
  status: string;
  target_url: string;
}

export type VendingSetupStatus = typeof VendingSetupStatus[keyof typeof VendingSetupStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VendingSetupStatus = {
  ok: 'ok',
  'no-config': 'no-config',
} as const;

/**
 * Configuration for a vended application
 */
export interface VendingSetup {
  status: VendingSetupStatus;
  currency: string;
  appshare: number;
  recommended_donation: number;
  minimum_payment: number;
}

/**
 * Configuration for a vended application
 */
export interface VendingSetupRequest {
  currency: string;
  appshare: number;
  recommended_donation: number;
  minimum_payment: number;
}

/**
 * The status object says whether the user is capable of receiving payments,
and also whether or not there are pending onboarding operations to complete
 */
export interface VendingStatus {
  status: string;
  can_take_payments: boolean;
  needs_attention: boolean;
  details_submitted: boolean;
}

export type VerificationMethod = typeof VerificationMethod[keyof typeof VerificationMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerificationMethod = {
  none: 'none',
  manual: 'manual',
  website: 'website',
  login_provider: 'login_provider',
} as const;

export type VerificationStatusLoginProviderDetail = string | null;

export type VerificationStatusLoginProviderLoginIsOrganization = boolean | null;

export interface VerificationStatusLoginProvider {
  verified: true;
  timestamp: string;
  method: 'login_provider';
  login_provider: LoginProvider;
  login_name: string;
  detail?: VerificationStatusLoginProviderDetail;
  login_is_organization?: VerificationStatusLoginProviderLoginIsOrganization;
}

export type VerificationStatusManualDetail = string | null;

export interface VerificationStatusManual {
  verified: true;
  timestamp: string;
  method: 'manual';
  detail?: VerificationStatusManualDetail;
}

export type VerificationStatusNoneDetail = string | null;

export interface VerificationStatusNone {
  verified: false;
  method: 'none';
  detail?: VerificationStatusNoneDetail;
}

export type VerificationStatusWebsiteDetail = string | null;

export interface VerificationStatusWebsite {
  verified: true;
  timestamp: string;
  method: 'website';
  website: string;
  detail?: VerificationStatusWebsiteDetail;
}

export interface WalletInfo {
  status: string;
  cards: PaymentCardInfo[];
}

export type WebsiteVerificationResultDetail = ErrorDetail | null;

export type WebsiteVerificationResultStatusCode = number | null;

export interface WebsiteVerificationResult {
  verified: boolean;
  detail?: WebsiteVerificationResultDetail;
  status_code?: WebsiteVerificationResultStatusCode;
}

export interface WebsiteVerificationToken {
  domain: string;
  token: string;
}

export type AppAppsSortBy = typeof AppAppsSortBy[keyof typeof AppAppsSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AppAppsSortBy = {
  alphabetical: 'alphabetical',
  'created-at': 'created-at',
  'last-updated-at': 'last-updated-at',
} as const;

export interface AppRoutesInvitesDevelopersResponse {
  developers: Developer[];
  invites: Developer[];
}

export type AppSchemasSortBy = typeof AppSchemasSortBy[keyof typeof AppSchemasSortBy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AppSchemasSortBy = {
  trending: 'trending',
  installs_last_month: 'installs_last_month',
} as const;

export interface AppSearchDevelopersResponse {
  developers: string[];
  total: number;
  page: number;
  per_page: number;
}

export type GetEolRebaseEolRebaseGet200 = {[key: string]: string[]};

export type GetEolRebaseAppidEolRebaseAppIdGetParams = {
branch?: string;
};

export type GetEolRebaseAppidEolRebaseAppIdGet200 = string | null;

export type GetEolMessageEolMessageGet200 = {[key: string]: string};

export type GetEolMessageAppidEolMessageAppIdGetParams = {
branch?: string;
};

export type GetEolMessageAppidEolMessageAppIdGet200 = string | null;

export type ListAppstreamAppstreamGetParams = {
filter?: AppType;
sort?: AppAppsSortBy;
};

export type GetAppstreamAppstreamAppIdGetParams = {
locale?: string;
};

export type GetAppstreamAppstreamAppIdGet200 = DesktopAppstream | AddonAppstream | LocalizationAppstream | GenericAppstream | RuntimeAppstream;

export type PostSearchSearchPostParams = {
locale?: string;
};

export type GetRuntimeListRuntimesGet200 = {[key: string]: number};

export type GetSummarySummaryAppIdGetParams = {
branch?: string | null;
};

export type GetPlatformsPlatformsGet200 = {[key: string]: Platform};

export type ContinueGithubFlowAuthLoginGithubPostBody = OauthLoginResponseSuccess | OauthLoginResponseFailure;

export type ContinueGitlabFlowAuthLoginGitlabPostBody = OauthLoginResponseSuccess | OauthLoginResponseFailure;

export type ContinueGnomeFlowAuthLoginGnomePostBody = OauthLoginResponseSuccess | OauthLoginResponseFailure;

export type ContinueKdeFlowAuthLoginKdePostBody = OauthLoginResponseSuccess | OauthLoginResponseFailure;

export type ContinueGoogleFlowAuthLoginGooglePostBody = OauthLoginResponseSuccess | OauthLoginResponseFailure;

export type GetUserinfoAuthUserinfoGet200 = UserInfo | null;

export type DoChangeDefaultAccountAuthChangeDefaultAccountPostParams = {
provider: ConnectedAccountProvider;
};

export type GetModerationAppsModerationAppsGetParams = {
new_submissions?: boolean | null;
show_handled?: boolean;
limit?: number;
offset?: number;
};

export type GetModerationAppModerationAppsAppIdGetParams = {
include_outdated?: boolean;
include_handled?: boolean;
limit?: number;
offset?: number;
};

export type GetTransactionsWalletTransactionsGetParams = {
sort?: TransactionSortOrder;
since?: string | null;
limit?: number;
};

export type GetVerificationStatusVerificationAppIdStatusGet200 = VerificationStatusNone | VerificationStatusManual | VerificationStatusWebsite | VerificationStatusLoginProvider;

export type GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams = {
new_app?: boolean;
};

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams = {
new_app?: boolean;
};

export type VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200 = ErrorReturn | null;

export type SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams = {
new_app?: boolean;
};

export type ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams = {
new_app?: boolean;
};

export type GetStorefrontInfoPurchasesStorefrontInfoGetParams = {
app_id: string;
};

export type GetIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetParams = {
app_id: string;
license?: string | null;
};

export type InviteDeveloperInvitesAppIdInvitePostParams = {
invite_code: string;
};

export type RemoveDeveloperInvitesAppIdRemoveDeveloperPostParams = {
developer_id: number;
};

export type RevokeInviteInvitesAppIdRevokePostParams = {
invite_id: number;
};

export type GetCategoryCollectionCategoryCategoryGetParams = {
exclude_subcategories?: string[];
page?: number | null;
per_page?: number | null;
locale?: string;
sort_by?: AppSchemasSortBy | null;
};

export type GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams = {
subcategory: string[];
exclude_subcategories?: string[];
page?: number | null;
per_page?: number | null;
locale?: string;
sort_by?: AppSchemasSortBy | null;
};

export type GetKeywordCollectionKeywordGetParams = {
keyword: string;
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetDevelopersCollectionDeveloperGetParams = {
page?: number | null;
per_page?: number | null;
};

export type GetDeveloperCollectionDeveloperDeveloperGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetRecentlyAddedCollectionRecentlyAddedGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetVerifiedCollectionVerifiedGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetMobileCollectionMobileGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetPopularLastMonthCollectionPopularGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetTrendingLastTwoWeeksCollectionTrendingGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetMostFavoritedCollectionFavoritesGetParams = {
page?: number | null;
per_page?: number | null;
locale?: string;
};

export type GetSearchCompatAppsSearchQueryGetParams = {
locale?: string;
};

export type GetQualityModerationStatusQualityModerationStatusGetParams = {
page?: number;
page_size?: number;
filter?: GetQualityModerationStatusQualityModerationStatusGetFilter;
};

export type GetQualityModerationStatusQualityModerationStatusGetFilter = typeof GetQualityModerationStatusQualityModerationStatusGetFilter[keyof typeof GetQualityModerationStatusQualityModerationStatusGetFilter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetQualityModerationStatusQualityModerationStatusGetFilter = {
  all: 'all',
  passing: 'passing',
  todo: 'todo',
} as const;

export type GetPassingQualityAppsQualityModerationPassingAppsGetParams = {
page?: number;
page_size?: number;
};

export type GetAppPickRecommendationsQualityModerationAppPickRecommendationsGetParams = {
recommendation_date?: string;
};

export type SetFullscreenAppQualityModerationAppIdFullscreenPostParams = {
is_fullscreen_app: boolean;
};

export type GetUploadTokensUploadTokensAppIdGetParams = {
include_expired?: boolean;
};

export type UsersUsersGetParams = {
page?: number;
page_size?: number;
filterString?: string | null;
};

export type AddUserRoleUsersUserIdRolePostParams = {
role: RoleName;
};

export type DeleteUserRoleUsersUserIdRoleDeleteParams = {
role: RoleName;
};

export type GetStatsStatsGet200 = StatsResult | null;

export type GetStatsForAppStatsAppIdGetParams = {
all?: boolean;
days?: number;
};

export type GetStatsForAppStatsAppIdGet200 = StatsResultApp | null;

/**
 * @summary Get Eol Rebase
 */
export type getEolRebaseEolRebaseGetResponse200 = {
  data: GetEolRebaseEolRebaseGet200
  status: 200
}
    
export type getEolRebaseEolRebaseGetResponseSuccess = (getEolRebaseEolRebaseGetResponse200) & {
  headers: Headers;
};
;

export type getEolRebaseEolRebaseGetResponse = (getEolRebaseEolRebaseGetResponseSuccess)

export const getGetEolRebaseEolRebaseGetUrl = () => {


  

  return `https://flathub.org/api/v2/eol/rebase`
}

export const getEolRebaseEolRebaseGet = async ( options?: RequestInit): Promise<getEolRebaseEolRebaseGetResponse> => {
  
  const res = await fetch(getGetEolRebaseEolRebaseGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEolRebaseEolRebaseGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEolRebaseEolRebaseGetResponse
}



/**
 * @summary Get Eol Rebase Appid
 */
export type getEolRebaseAppidEolRebaseAppIdGetResponse200 = {
  data: GetEolRebaseAppidEolRebaseAppIdGet200
  status: 200
}

export type getEolRebaseAppidEolRebaseAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getEolRebaseAppidEolRebaseAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getEolRebaseAppidEolRebaseAppIdGetResponseSuccess = (getEolRebaseAppidEolRebaseAppIdGetResponse200) & {
  headers: Headers;
};
export type getEolRebaseAppidEolRebaseAppIdGetResponseError = (getEolRebaseAppidEolRebaseAppIdGetResponse404 | getEolRebaseAppidEolRebaseAppIdGetResponse422) & {
  headers: Headers;
};

export type getEolRebaseAppidEolRebaseAppIdGetResponse = (getEolRebaseAppidEolRebaseAppIdGetResponseSuccess | getEolRebaseAppidEolRebaseAppIdGetResponseError)

export const getGetEolRebaseAppidEolRebaseAppIdGetUrl = (appId: string,
    params?: GetEolRebaseAppidEolRebaseAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/eol/rebase/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/eol/rebase/${appId}`
}

export const getEolRebaseAppidEolRebaseAppIdGet = async (appId: string,
    params?: GetEolRebaseAppidEolRebaseAppIdGetParams, options?: RequestInit): Promise<getEolRebaseAppidEolRebaseAppIdGetResponse> => {
  
  const res = await fetch(getGetEolRebaseAppidEolRebaseAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEolRebaseAppidEolRebaseAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEolRebaseAppidEolRebaseAppIdGetResponse
}



/**
 * @summary Get Eol Message
 */
export type getEolMessageEolMessageGetResponse200 = {
  data: GetEolMessageEolMessageGet200
  status: 200
}
    
export type getEolMessageEolMessageGetResponseSuccess = (getEolMessageEolMessageGetResponse200) & {
  headers: Headers;
};
;

export type getEolMessageEolMessageGetResponse = (getEolMessageEolMessageGetResponseSuccess)

export const getGetEolMessageEolMessageGetUrl = () => {


  

  return `https://flathub.org/api/v2/eol/message`
}

export const getEolMessageEolMessageGet = async ( options?: RequestInit): Promise<getEolMessageEolMessageGetResponse> => {
  
  const res = await fetch(getGetEolMessageEolMessageGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEolMessageEolMessageGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEolMessageEolMessageGetResponse
}



/**
 * @summary Get Eol Message Appid
 */
export type getEolMessageAppidEolMessageAppIdGetResponse200 = {
  data: GetEolMessageAppidEolMessageAppIdGet200
  status: 200
}

export type getEolMessageAppidEolMessageAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getEolMessageAppidEolMessageAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getEolMessageAppidEolMessageAppIdGetResponseSuccess = (getEolMessageAppidEolMessageAppIdGetResponse200) & {
  headers: Headers;
};
export type getEolMessageAppidEolMessageAppIdGetResponseError = (getEolMessageAppidEolMessageAppIdGetResponse404 | getEolMessageAppidEolMessageAppIdGetResponse422) & {
  headers: Headers;
};

export type getEolMessageAppidEolMessageAppIdGetResponse = (getEolMessageAppidEolMessageAppIdGetResponseSuccess | getEolMessageAppidEolMessageAppIdGetResponseError)

export const getGetEolMessageAppidEolMessageAppIdGetUrl = (appId: string,
    params?: GetEolMessageAppidEolMessageAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/eol/message/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/eol/message/${appId}`
}

export const getEolMessageAppidEolMessageAppIdGet = async (appId: string,
    params?: GetEolMessageAppidEolMessageAppIdGetParams, options?: RequestInit): Promise<getEolMessageAppidEolMessageAppIdGetResponse> => {
  
  const res = await fetch(getGetEolMessageAppidEolMessageAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getEolMessageAppidEolMessageAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getEolMessageAppidEolMessageAppIdGetResponse
}



/**
 * Get a list of all application IDs in the repository.

- **filter**: Filter by app type (default: apps)
- **sort**: Sort order (default: alphabetical)
  - `alphabetical`: Sort by app ID alphabetically
  - `created-at`: Sort by creation date (newest first)
  - `last-updated-at`: Sort by last update date (newest first)
 * @summary List Appstream
 */
export type listAppstreamAppstreamGetResponse200 = {
  data: string[]
  status: 200
}

export type listAppstreamAppstreamGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type listAppstreamAppstreamGetResponseSuccess = (listAppstreamAppstreamGetResponse200) & {
  headers: Headers;
};
export type listAppstreamAppstreamGetResponseError = (listAppstreamAppstreamGetResponse422) & {
  headers: Headers;
};

export type listAppstreamAppstreamGetResponse = (listAppstreamAppstreamGetResponseSuccess | listAppstreamAppstreamGetResponseError)

export const getListAppstreamAppstreamGetUrl = (params?: ListAppstreamAppstreamGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/appstream?${stringifiedParams}` : `https://flathub.org/api/v2/appstream`
}

export const listAppstreamAppstreamGet = async (params?: ListAppstreamAppstreamGetParams, options?: RequestInit): Promise<listAppstreamAppstreamGetResponse> => {
  
  const res = await fetch(getListAppstreamAppstreamGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listAppstreamAppstreamGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listAppstreamAppstreamGetResponse
}



/**
 * Get the AppStream metadata for a specific application.

Returns the full appstream data including name, description, screenshots,
releases, and other metadata. The response is localized based on the
locale parameter.
 * @summary Get Appstream
 */
export type getAppstreamAppstreamAppIdGetResponse200 = {
  data: GetAppstreamAppstreamAppIdGet200
  status: 200
}

export type getAppstreamAppstreamAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getAppstreamAppstreamAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getAppstreamAppstreamAppIdGetResponseSuccess = (getAppstreamAppstreamAppIdGetResponse200) & {
  headers: Headers;
};
export type getAppstreamAppstreamAppIdGetResponseError = (getAppstreamAppstreamAppIdGetResponse404 | getAppstreamAppstreamAppIdGetResponse422) & {
  headers: Headers;
};

export type getAppstreamAppstreamAppIdGetResponse = (getAppstreamAppstreamAppIdGetResponseSuccess | getAppstreamAppstreamAppIdGetResponseError)

export const getGetAppstreamAppstreamAppIdGetUrl = (appId: string,
    params?: GetAppstreamAppstreamAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/appstream/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/appstream/${appId}`
}

export const getAppstreamAppstreamAppIdGet = async (appId: string,
    params?: GetAppstreamAppstreamAppIdGetParams, options?: RequestInit): Promise<getAppstreamAppstreamAppIdGetResponse> => {
  
  const res = await fetch(getGetAppstreamAppstreamAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppstreamAppstreamAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppstreamAppstreamAppIdGetResponse
}



/**
 * Check if an application is configured to run in fullscreen mode.
 * @summary Get Isfullscreenapp
 */
export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse200 = {
  data: boolean
  status: 200
}

export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getIsFullscreenAppIsFullscreenAppAppIdGetResponseSuccess = (getIsFullscreenAppIsFullscreenAppAppIdGetResponse200) & {
  headers: Headers;
};
export type getIsFullscreenAppIsFullscreenAppAppIdGetResponseError = (getIsFullscreenAppIsFullscreenAppAppIdGetResponse422) & {
  headers: Headers;
};

export type getIsFullscreenAppIsFullscreenAppAppIdGetResponse = (getIsFullscreenAppIsFullscreenAppAppIdGetResponseSuccess | getIsFullscreenAppIsFullscreenAppAppIdGetResponseError)

export const getGetIsFullscreenAppIsFullscreenAppAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/is-fullscreen-app/${appId}`
}

export const getIsFullscreenAppIsFullscreenAppAppIdGet = async (appId: string, options?: RequestInit): Promise<getIsFullscreenAppIsFullscreenAppAppIdGetResponse> => {
  
  const res = await fetch(getGetIsFullscreenAppIsFullscreenAppAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getIsFullscreenAppIsFullscreenAppAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getIsFullscreenAppIsFullscreenAppAppIdGetResponse
}



/**
 * Search for applications using Meilisearch.

Accepts a search query with filters and returns matching applications
with facets and pagination information.
 * @summary Post Search
 */
export type postSearchSearchPostResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type postSearchSearchPostResponse400 = {
  data: void
  status: 400
}

export type postSearchSearchPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type postSearchSearchPostResponseSuccess = (postSearchSearchPostResponse200) & {
  headers: Headers;
};
export type postSearchSearchPostResponseError = (postSearchSearchPostResponse400 | postSearchSearchPostResponse422) & {
  headers: Headers;
};

export type postSearchSearchPostResponse = (postSearchSearchPostResponseSuccess | postSearchSearchPostResponseError)

export const getPostSearchSearchPostUrl = (params?: PostSearchSearchPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/search?${stringifiedParams}` : `https://flathub.org/api/v2/search`
}

export const postSearchSearchPost = async (searchQuery: SearchQuery,
    params?: PostSearchSearchPostParams, options?: RequestInit): Promise<postSearchSearchPostResponse> => {
  
  const res = await fetch(getPostSearchSearchPostUrl(params),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      searchQuery,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postSearchSearchPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postSearchSearchPostResponse
}



/**
 * Get a list of available Flatpak runtimes with usage counts.

Returns a mapping of runtime names to the number of apps using each runtime.
 * @summary Get Runtime List
 */
export type getRuntimeListRuntimesGetResponse200 = {
  data: GetRuntimeListRuntimesGet200
  status: 200
}
    
export type getRuntimeListRuntimesGetResponseSuccess = (getRuntimeListRuntimesGetResponse200) & {
  headers: Headers;
};
;

export type getRuntimeListRuntimesGetResponse = (getRuntimeListRuntimesGetResponseSuccess)

export const getGetRuntimeListRuntimesGetUrl = () => {


  

  return `https://flathub.org/api/v2/runtimes`
}

export const getRuntimeListRuntimesGet = async ( options?: RequestInit): Promise<getRuntimeListRuntimesGetResponse> => {
  
  const res = await fetch(getGetRuntimeListRuntimesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRuntimeListRuntimesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRuntimeListRuntimesGetResponse
}



/**
 * Get summary information for a specific application.

Returns information about the app's size, architectures, runtime metadata,
and flatpak-specific configuration.
 * @summary Get Summary
 */
export type getSummarySummaryAppIdGetResponse200 = {
  data: SummaryResponse
  status: 200
}

export type getSummarySummaryAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getSummarySummaryAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getSummarySummaryAppIdGetResponseSuccess = (getSummarySummaryAppIdGetResponse200) & {
  headers: Headers;
};
export type getSummarySummaryAppIdGetResponseError = (getSummarySummaryAppIdGetResponse404 | getSummarySummaryAppIdGetResponse422) & {
  headers: Headers;
};

export type getSummarySummaryAppIdGetResponse = (getSummarySummaryAppIdGetResponseSuccess | getSummarySummaryAppIdGetResponseError)

export const getGetSummarySummaryAppIdGetUrl = (appId: string,
    params?: GetSummarySummaryAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/summary/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/summary/${appId}`
}

export const getSummarySummaryAppIdGet = async (appId: string,
    params?: GetSummarySummaryAppIdGetParams, options?: RequestInit): Promise<getSummarySummaryAppIdGetResponse> => {
  
  const res = await fetch(getGetSummarySummaryAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSummarySummaryAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSummarySummaryAppIdGetResponse
}



/**
 * Return a mapping from org-name to platform aliases and dependencies which are
recognised by the backend.  These are used by things such as the transactions
and donations APIs to address amounts to the platforms.
 * @summary Get Platforms
 */
export type getPlatformsPlatformsGetResponse200 = {
  data: GetPlatformsPlatformsGet200
  status: 200
}
    
export type getPlatformsPlatformsGetResponseSuccess = (getPlatformsPlatformsGetResponse200) & {
  headers: Headers;
};
;

export type getPlatformsPlatformsGetResponse = (getPlatformsPlatformsGetResponseSuccess)

export const getGetPlatformsPlatformsGetUrl = () => {


  

  return `https://flathub.org/api/v2/platforms`
}

export const getPlatformsPlatformsGet = async ( options?: RequestInit): Promise<getPlatformsPlatformsGetResponse> => {
  
  const res = await fetch(getGetPlatformsPlatformsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPlatformsPlatformsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPlatformsPlatformsGetResponse
}



/**
 * Get a list of addon IDs that are compatible with the specified application.

Addons extend the functionality of base applications (e.g., codecs, themes).
 * @summary Get Addons
 */
export type getAddonsAddonAppIdGetResponse200 = {
  data: string[]
  status: 200
}

export type getAddonsAddonAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getAddonsAddonAppIdGetResponseSuccess = (getAddonsAddonAppIdGetResponse200) & {
  headers: Headers;
};
export type getAddonsAddonAppIdGetResponseError = (getAddonsAddonAppIdGetResponse422) & {
  headers: Headers;
};

export type getAddonsAddonAppIdGetResponse = (getAddonsAddonAppIdGetResponseSuccess | getAddonsAddonAppIdGetResponseError)

export const getGetAddonsAddonAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/addon/${appId}`
}

export const getAddonsAddonAppIdGet = async (appId: string, options?: RequestInit): Promise<getAddonsAddonAppIdGetResponse> => {
  
  const res = await fetch(getGetAddonsAddonAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAddonsAddonAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAddonsAddonAppIdGetResponse
}



/**
 * @summary Update
 */
export type updateUpdatePostResponse200 = {
  data: unknown
  status: 200
}

export type updateUpdatePostResponse500 = {
  data: void
  status: 500
}
    
export type updateUpdatePostResponseSuccess = (updateUpdatePostResponse200) & {
  headers: Headers;
};
export type updateUpdatePostResponseError = (updateUpdatePostResponse500) & {
  headers: Headers;
};

export type updateUpdatePostResponse = (updateUpdatePostResponseSuccess | updateUpdatePostResponseError)

export const getUpdateUpdatePostUrl = () => {


  

  return `https://flathub.org/api/v2/update`
}

export const updateUpdatePost = async ( options?: RequestInit): Promise<updateUpdatePostResponse> => {
  
  const res = await fetch(getUpdateUpdatePostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUpdatePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUpdatePostResponse
}



/**
 * @summary Update Stats
 */
export type updateStatsUpdateStatsPostResponse200 = {
  data: unknown
  status: 200
}

export type updateStatsUpdateStatsPostResponse500 = {
  data: void
  status: 500
}
    
export type updateStatsUpdateStatsPostResponseSuccess = (updateStatsUpdateStatsPostResponse200) & {
  headers: Headers;
};
export type updateStatsUpdateStatsPostResponseError = (updateStatsUpdateStatsPostResponse500) & {
  headers: Headers;
};

export type updateStatsUpdateStatsPostResponse = (updateStatsUpdateStatsPostResponseSuccess | updateStatsUpdateStatsPostResponseError)

export const getUpdateStatsUpdateStatsPostUrl = () => {


  

  return `https://flathub.org/api/v2/update/stats`
}

export const updateStatsUpdateStatsPost = async ( options?: RequestInit): Promise<updateStatsUpdateStatsPostResponse> => {
  
  const res = await fetch(getUpdateStatsUpdateStatsPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateStatsUpdateStatsPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateStatsUpdateStatsPostResponse
}



/**
 * Process any pending transfers which may be in the system
 * @summary Process Transfers
 */
export type processTransfersUpdateProcessPendingTransfersPostResponse200 = {
  data: unknown
  status: 200
}

export type processTransfersUpdateProcessPendingTransfersPostResponse500 = {
  data: void
  status: 500
}
    
export type processTransfersUpdateProcessPendingTransfersPostResponseSuccess = (processTransfersUpdateProcessPendingTransfersPostResponse200) & {
  headers: Headers;
};
export type processTransfersUpdateProcessPendingTransfersPostResponseError = (processTransfersUpdateProcessPendingTransfersPostResponse500) & {
  headers: Headers;
};

export type processTransfersUpdateProcessPendingTransfersPostResponse = (processTransfersUpdateProcessPendingTransfersPostResponseSuccess | processTransfersUpdateProcessPendingTransfersPostResponseError)

export const getProcessTransfersUpdateProcessPendingTransfersPostUrl = () => {


  

  return `https://flathub.org/api/v2/update/process-pending-transfers`
}

export const processTransfersUpdateProcessPendingTransfersPost = async ( options?: RequestInit): Promise<processTransfersUpdateProcessPendingTransfersPostResponse> => {
  
  const res = await fetch(getProcessTransfersUpdateProcessPendingTransfersPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: processTransfersUpdateProcessPendingTransfersPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as processTransfersUpdateProcessPendingTransfersPostResponse
}



/**
 * @summary Build Notification
 */
export type buildNotificationEmailsBuildNotificationPostResponse200 = {
  data: unknown
  status: 200
}

export type buildNotificationEmailsBuildNotificationPostResponse422 = {
  data: void
  status: 422
}

export type buildNotificationEmailsBuildNotificationPostResponse500 = {
  data: void
  status: 500
}
    
export type buildNotificationEmailsBuildNotificationPostResponseSuccess = (buildNotificationEmailsBuildNotificationPostResponse200) & {
  headers: Headers;
};
export type buildNotificationEmailsBuildNotificationPostResponseError = (buildNotificationEmailsBuildNotificationPostResponse422 | buildNotificationEmailsBuildNotificationPostResponse500) & {
  headers: Headers;
};

export type buildNotificationEmailsBuildNotificationPostResponse = (buildNotificationEmailsBuildNotificationPostResponseSuccess | buildNotificationEmailsBuildNotificationPostResponseError)

export const getBuildNotificationEmailsBuildNotificationPostUrl = () => {


  

  return `https://flathub.org/api/v2/emails/build-notification`
}

export const buildNotificationEmailsBuildNotificationPost = async (buildNotificationRequest: BuildNotificationRequest, options?: RequestInit): Promise<buildNotificationEmailsBuildNotificationPostResponse> => {
  
  const res = await fetch(getBuildNotificationEmailsBuildNotificationPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      buildNotificationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: buildNotificationEmailsBuildNotificationPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as buildNotificationEmailsBuildNotificationPostResponse
}



/**
 * Retrieve the login methods available from the backend.

For each method returned, flow starts with a `GET` to the endpoint
`.../login/{method}` and upon completion from the user-agent, with a `POST`
to that same endpoint name.

Each method is also given a button icon and some text to use, though
frontends with localisation may choose to render other text instead.
 * @summary Get Login Methods
 */
export type getLoginMethodsAuthLoginGetResponse200 = {
  data: LoginMethod[]
  status: 200
}
    
export type getLoginMethodsAuthLoginGetResponseSuccess = (getLoginMethodsAuthLoginGetResponse200) & {
  headers: Headers;
};
;

export type getLoginMethodsAuthLoginGetResponse = (getLoginMethodsAuthLoginGetResponseSuccess)

export const getGetLoginMethodsAuthLoginGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login`
}

export const getLoginMethodsAuthLoginGet = async ( options?: RequestInit): Promise<getLoginMethodsAuthLoginGetResponse> => {
  
  const res = await fetch(getGetLoginMethodsAuthLoginGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLoginMethodsAuthLoginGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLoginMethodsAuthLoginGetResponse
}



/**
 * Starts a github login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Github

Upon return from Github to the frontend, the frontend should POST to this
endpoint with the relevant data from Github

If the user is already logged in, and has a valid github token stored,
then this will return an error instead.
 * @summary Start Github Flow
 */
export type startGithubFlowAuthLoginGithubGetResponse200 = {
  data: unknown
  status: 200
}

export type startGithubFlowAuthLoginGithubGetResponse400 = {
  data: void
  status: 400
}
    
export type startGithubFlowAuthLoginGithubGetResponseSuccess = (startGithubFlowAuthLoginGithubGetResponse200) & {
  headers: Headers;
};
export type startGithubFlowAuthLoginGithubGetResponseError = (startGithubFlowAuthLoginGithubGetResponse400) & {
  headers: Headers;
};

export type startGithubFlowAuthLoginGithubGetResponse = (startGithubFlowAuthLoginGithubGetResponseSuccess | startGithubFlowAuthLoginGithubGetResponseError)

export const getStartGithubFlowAuthLoginGithubGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/github`
}

export const startGithubFlowAuthLoginGithubGet = async ( options?: RequestInit): Promise<startGithubFlowAuthLoginGithubGetResponse> => {
  
  const res = await fetch(getStartGithubFlowAuthLoginGithubGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startGithubFlowAuthLoginGithubGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startGithubFlowAuthLoginGithubGetResponse
}



/**
 * Process the result of the Github oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the github oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from github",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Github Flow
 */
export type continueGithubFlowAuthLoginGithubPostResponse200 = {
  data: unknown
  status: 200
}

export type continueGithubFlowAuthLoginGithubPostResponse400 = {
  data: void
  status: 400
}

export type continueGithubFlowAuthLoginGithubPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGithubFlowAuthLoginGithubPostResponse500 = {
  data: void
  status: 500
}
    
export type continueGithubFlowAuthLoginGithubPostResponseSuccess = (continueGithubFlowAuthLoginGithubPostResponse200) & {
  headers: Headers;
};
export type continueGithubFlowAuthLoginGithubPostResponseError = (continueGithubFlowAuthLoginGithubPostResponse400 | continueGithubFlowAuthLoginGithubPostResponse422 | continueGithubFlowAuthLoginGithubPostResponse500) & {
  headers: Headers;
};

export type continueGithubFlowAuthLoginGithubPostResponse = (continueGithubFlowAuthLoginGithubPostResponseSuccess | continueGithubFlowAuthLoginGithubPostResponseError)

export const getContinueGithubFlowAuthLoginGithubPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/github`
}

export const continueGithubFlowAuthLoginGithubPost = async (continueGithubFlowAuthLoginGithubPostBody: ContinueGithubFlowAuthLoginGithubPostBody, options?: RequestInit): Promise<continueGithubFlowAuthLoginGithubPostResponse> => {
  
  const res = await fetch(getContinueGithubFlowAuthLoginGithubPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      continueGithubFlowAuthLoginGithubPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: continueGithubFlowAuthLoginGithubPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as continueGithubFlowAuthLoginGithubPostResponse
}



/**
 * Starts a gitlab login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to Gitlab

Upon return from Gitlab to the frontend, the frontend should POST to this
endpoint with the relevant data from Gitlab

If the user is already logged in, and has a valid gitlab token stored,
then this will return an error instead.
 * @summary Start Gitlab Flow
 */
export type startGitlabFlowAuthLoginGitlabGetResponse200 = {
  data: unknown
  status: 200
}

export type startGitlabFlowAuthLoginGitlabGetResponse400 = {
  data: void
  status: 400
}
    
export type startGitlabFlowAuthLoginGitlabGetResponseSuccess = (startGitlabFlowAuthLoginGitlabGetResponse200) & {
  headers: Headers;
};
export type startGitlabFlowAuthLoginGitlabGetResponseError = (startGitlabFlowAuthLoginGitlabGetResponse400) & {
  headers: Headers;
};

export type startGitlabFlowAuthLoginGitlabGetResponse = (startGitlabFlowAuthLoginGitlabGetResponseSuccess | startGitlabFlowAuthLoginGitlabGetResponseError)

export const getStartGitlabFlowAuthLoginGitlabGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/gitlab`
}

export const startGitlabFlowAuthLoginGitlabGet = async ( options?: RequestInit): Promise<startGitlabFlowAuthLoginGitlabGetResponse> => {
  
  const res = await fetch(getStartGitlabFlowAuthLoginGitlabGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startGitlabFlowAuthLoginGitlabGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startGitlabFlowAuthLoginGitlabGetResponse
}



/**
 * Process the result of the Gitlab oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gitlab Flow
 */
export type continueGitlabFlowAuthLoginGitlabPostResponse200 = {
  data: unknown
  status: 200
}

export type continueGitlabFlowAuthLoginGitlabPostResponse400 = {
  data: void
  status: 400
}

export type continueGitlabFlowAuthLoginGitlabPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGitlabFlowAuthLoginGitlabPostResponse500 = {
  data: void
  status: 500
}
    
export type continueGitlabFlowAuthLoginGitlabPostResponseSuccess = (continueGitlabFlowAuthLoginGitlabPostResponse200) & {
  headers: Headers;
};
export type continueGitlabFlowAuthLoginGitlabPostResponseError = (continueGitlabFlowAuthLoginGitlabPostResponse400 | continueGitlabFlowAuthLoginGitlabPostResponse422 | continueGitlabFlowAuthLoginGitlabPostResponse500) & {
  headers: Headers;
};

export type continueGitlabFlowAuthLoginGitlabPostResponse = (continueGitlabFlowAuthLoginGitlabPostResponseSuccess | continueGitlabFlowAuthLoginGitlabPostResponseError)

export const getContinueGitlabFlowAuthLoginGitlabPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/gitlab`
}

export const continueGitlabFlowAuthLoginGitlabPost = async (continueGitlabFlowAuthLoginGitlabPostBody: ContinueGitlabFlowAuthLoginGitlabPostBody, options?: RequestInit): Promise<continueGitlabFlowAuthLoginGitlabPostResponse> => {
  
  const res = await fetch(getContinueGitlabFlowAuthLoginGitlabPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      continueGitlabFlowAuthLoginGitlabPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: continueGitlabFlowAuthLoginGitlabPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as continueGitlabFlowAuthLoginGitlabPostResponse
}



/**
 * Starts a GNOME login flow.  This will set session cookie values and
will return a redirect.  The frontend is expected to save the cookie
for use later, and follow the redirect to GNOME Gitlab

Upon return from GNOME to the frontend, the frontend should POST to this
endpoint with the relevant data from GNOME Gitlab

If the user is already logged in, and has a valid GNOME Gitlab token stored,
then this will return an error instead.
 * @summary Start Gnome Flow
 */
export type startGnomeFlowAuthLoginGnomeGetResponse200 = {
  data: unknown
  status: 200
}

export type startGnomeFlowAuthLoginGnomeGetResponse400 = {
  data: void
  status: 400
}
    
export type startGnomeFlowAuthLoginGnomeGetResponseSuccess = (startGnomeFlowAuthLoginGnomeGetResponse200) & {
  headers: Headers;
};
export type startGnomeFlowAuthLoginGnomeGetResponseError = (startGnomeFlowAuthLoginGnomeGetResponse400) & {
  headers: Headers;
};

export type startGnomeFlowAuthLoginGnomeGetResponse = (startGnomeFlowAuthLoginGnomeGetResponseSuccess | startGnomeFlowAuthLoginGnomeGetResponseError)

export const getStartGnomeFlowAuthLoginGnomeGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/gnome`
}

export const startGnomeFlowAuthLoginGnomeGet = async ( options?: RequestInit): Promise<startGnomeFlowAuthLoginGnomeGetResponse> => {
  
  const res = await fetch(getStartGnomeFlowAuthLoginGnomeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startGnomeFlowAuthLoginGnomeGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startGnomeFlowAuthLoginGnomeGetResponse
}



/**
 * Process the result of the GNOME oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the gitlab oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from GNOME gitlab",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Gnome Flow
 */
export type continueGnomeFlowAuthLoginGnomePostResponse200 = {
  data: unknown
  status: 200
}

export type continueGnomeFlowAuthLoginGnomePostResponse400 = {
  data: void
  status: 400
}

export type continueGnomeFlowAuthLoginGnomePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGnomeFlowAuthLoginGnomePostResponse500 = {
  data: void
  status: 500
}
    
export type continueGnomeFlowAuthLoginGnomePostResponseSuccess = (continueGnomeFlowAuthLoginGnomePostResponse200) & {
  headers: Headers;
};
export type continueGnomeFlowAuthLoginGnomePostResponseError = (continueGnomeFlowAuthLoginGnomePostResponse400 | continueGnomeFlowAuthLoginGnomePostResponse422 | continueGnomeFlowAuthLoginGnomePostResponse500) & {
  headers: Headers;
};

export type continueGnomeFlowAuthLoginGnomePostResponse = (continueGnomeFlowAuthLoginGnomePostResponseSuccess | continueGnomeFlowAuthLoginGnomePostResponseError)

export const getContinueGnomeFlowAuthLoginGnomePostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/gnome`
}

export const continueGnomeFlowAuthLoginGnomePost = async (continueGnomeFlowAuthLoginGnomePostBody: ContinueGnomeFlowAuthLoginGnomePostBody, options?: RequestInit): Promise<continueGnomeFlowAuthLoginGnomePostResponse> => {
  
  const res = await fetch(getContinueGnomeFlowAuthLoginGnomePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      continueGnomeFlowAuthLoginGnomePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: continueGnomeFlowAuthLoginGnomePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as continueGnomeFlowAuthLoginGnomePostResponse
}



/**
 * @summary Start Kde Flow
 */
export type startKdeFlowAuthLoginKdeGetResponse200 = {
  data: unknown
  status: 200
}

export type startKdeFlowAuthLoginKdeGetResponse400 = {
  data: void
  status: 400
}
    
export type startKdeFlowAuthLoginKdeGetResponseSuccess = (startKdeFlowAuthLoginKdeGetResponse200) & {
  headers: Headers;
};
export type startKdeFlowAuthLoginKdeGetResponseError = (startKdeFlowAuthLoginKdeGetResponse400) & {
  headers: Headers;
};

export type startKdeFlowAuthLoginKdeGetResponse = (startKdeFlowAuthLoginKdeGetResponseSuccess | startKdeFlowAuthLoginKdeGetResponseError)

export const getStartKdeFlowAuthLoginKdeGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/kde`
}

export const startKdeFlowAuthLoginKdeGet = async ( options?: RequestInit): Promise<startKdeFlowAuthLoginKdeGetResponse> => {
  
  const res = await fetch(getStartKdeFlowAuthLoginKdeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startKdeFlowAuthLoginKdeGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startKdeFlowAuthLoginKdeGetResponse
}



/**
 * @summary Continue Kde Flow
 */
export type continueKdeFlowAuthLoginKdePostResponse200 = {
  data: unknown
  status: 200
}

export type continueKdeFlowAuthLoginKdePostResponse400 = {
  data: void
  status: 400
}

export type continueKdeFlowAuthLoginKdePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueKdeFlowAuthLoginKdePostResponse500 = {
  data: void
  status: 500
}
    
export type continueKdeFlowAuthLoginKdePostResponseSuccess = (continueKdeFlowAuthLoginKdePostResponse200) & {
  headers: Headers;
};
export type continueKdeFlowAuthLoginKdePostResponseError = (continueKdeFlowAuthLoginKdePostResponse400 | continueKdeFlowAuthLoginKdePostResponse422 | continueKdeFlowAuthLoginKdePostResponse500) & {
  headers: Headers;
};

export type continueKdeFlowAuthLoginKdePostResponse = (continueKdeFlowAuthLoginKdePostResponseSuccess | continueKdeFlowAuthLoginKdePostResponseError)

export const getContinueKdeFlowAuthLoginKdePostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/kde`
}

export const continueKdeFlowAuthLoginKdePost = async (continueKdeFlowAuthLoginKdePostBody: ContinueKdeFlowAuthLoginKdePostBody, options?: RequestInit): Promise<continueKdeFlowAuthLoginKdePostResponse> => {
  
  const res = await fetch(getContinueKdeFlowAuthLoginKdePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      continueKdeFlowAuthLoginKdePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: continueKdeFlowAuthLoginKdePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as continueKdeFlowAuthLoginKdePostResponse
}



/**
 * Process the result of the Google oauth flow

This expects to have some JSON posted to it which (on success) contains:

```
{
    "state": "the state code",
    "code": "the google oauth code",
}
```

On failure, the frontend should pass through the state and error so that
the backend can clear the flow tokens

```
{
    "state": "the state code",
    "error": "the error code returned from google",
}
```

This endpoint will either return an error, if something was wrong in the
backend state machines; or it will return a success code with an indication
of whether or not the login sequence completed OK.
 * @summary Continue Google Flow
 */
export type continueGoogleFlowAuthLoginGooglePostResponse200 = {
  data: unknown
  status: 200
}

export type continueGoogleFlowAuthLoginGooglePostResponse400 = {
  data: void
  status: 400
}

export type continueGoogleFlowAuthLoginGooglePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type continueGoogleFlowAuthLoginGooglePostResponse500 = {
  data: void
  status: 500
}
    
export type continueGoogleFlowAuthLoginGooglePostResponseSuccess = (continueGoogleFlowAuthLoginGooglePostResponse200) & {
  headers: Headers;
};
export type continueGoogleFlowAuthLoginGooglePostResponseError = (continueGoogleFlowAuthLoginGooglePostResponse400 | continueGoogleFlowAuthLoginGooglePostResponse422 | continueGoogleFlowAuthLoginGooglePostResponse500) & {
  headers: Headers;
};

export type continueGoogleFlowAuthLoginGooglePostResponse = (continueGoogleFlowAuthLoginGooglePostResponseSuccess | continueGoogleFlowAuthLoginGooglePostResponseError)

export const getContinueGoogleFlowAuthLoginGooglePostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/login/google`
}

export const continueGoogleFlowAuthLoginGooglePost = async (continueGoogleFlowAuthLoginGooglePostBody: ContinueGoogleFlowAuthLoginGooglePostBody, options?: RequestInit): Promise<continueGoogleFlowAuthLoginGooglePostResponse> => {
  
  const res = await fetch(getContinueGoogleFlowAuthLoginGooglePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      continueGoogleFlowAuthLoginGooglePostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: continueGoogleFlowAuthLoginGooglePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as continueGoogleFlowAuthLoginGooglePostResponse
}



/**
 * Retrieve the current login's user information.  If the user is not logged in
you will get a `204` return.  Otherwise you will receive JSON describing the
currently logged in user, for example:

```
{
    "displayname": "Mx Human Person",
    "dev_flatpaks": [ "org.people.human.Appname" ],
    "owned_flatpaks": [ "org.foo.bar.Appname" ],
    "accepted_publisher-agreement_at": "2023-06-23T20:38:28.553028"
}
```

If the user has an active github login, you'll also get their github login
name, and avatar.  If they have some other login, details for that login
will be provided.

dev_flatpaks is filtered against IDs available in AppStream
 * @summary Get Userinfo
 */
export type getUserinfoAuthUserinfoGetResponse200 = {
  data: GetUserinfoAuthUserinfoGet200
  status: 200
}

export type getUserinfoAuthUserinfoGetResponse204 = {
  data: void
  status: 204
}
    
export type getUserinfoAuthUserinfoGetResponseSuccess = (getUserinfoAuthUserinfoGetResponse200 | getUserinfoAuthUserinfoGetResponse204) & {
  headers: Headers;
};
;

export type getUserinfoAuthUserinfoGetResponse = (getUserinfoAuthUserinfoGetResponseSuccess)

export const getGetUserinfoAuthUserinfoGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/userinfo`
}

export const getUserinfoAuthUserinfoGet = async ( options?: RequestInit): Promise<getUserinfoAuthUserinfoGetResponse> => {
  
  const res = await fetch(getGetUserinfoAuthUserinfoGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserinfoAuthUserinfoGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserinfoAuthUserinfoGetResponse
}



/**
 * @summary Do Refresh Dev Flatpaks
 */
export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse200 = {
  data: RefreshDevFlatpaksReturn
  status: 200
}

export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse401 = {
  data: void
  status: 401
}
    
export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseSuccess = (doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse200) & {
  headers: Headers;
};
export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseError = (doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse401) & {
  headers: Headers;
};

export type doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse = (doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseSuccess | doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponseError)

export const getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/refresh-dev-flatpaks`
}

export const doRefreshDevFlatpaksAuthRefreshDevFlatpaksPost = async ( options?: RequestInit): Promise<doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse> => {
  
  const res = await fetch(getDoRefreshDevFlatpaksAuthRefreshDevFlatpaksPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as doRefreshDevFlatpaksAuthRefreshDevFlatpaksPostResponse
}



/**
 * Clear the login state. This will discard tokens which access socials,
and will clear the session cookie so that the user is not logged in.
 * @summary Do Logout
 */
export type doLogoutAuthLogoutPostResponse200 = {
  data: unknown
  status: 200
}

export type doLogoutAuthLogoutPostResponse500 = {
  data: void
  status: 500
}
    
export type doLogoutAuthLogoutPostResponseSuccess = (doLogoutAuthLogoutPostResponse200) & {
  headers: Headers;
};
export type doLogoutAuthLogoutPostResponseError = (doLogoutAuthLogoutPostResponse500) & {
  headers: Headers;
};

export type doLogoutAuthLogoutPostResponse = (doLogoutAuthLogoutPostResponseSuccess | doLogoutAuthLogoutPostResponseError)

export const getDoLogoutAuthLogoutPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/logout`
}

export const doLogoutAuthLogoutPost = async ( options?: RequestInit): Promise<doLogoutAuthLogoutPostResponse> => {
  
  const res = await fetch(getDoLogoutAuthLogoutPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: doLogoutAuthLogoutPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as doLogoutAuthLogoutPostResponse
}



/**
 * Delete a user's login information.
If they're not logged in, they'll get a `403` return.
Otherwise they will get an option to delete their account
and data.
 * @summary Get Deleteuser
 */
export type getDeleteuserAuthDeleteuserGetResponse200 = {
  data: GetDeleteUserResult
  status: 200
}

export type getDeleteuserAuthDeleteuserGetResponse403 = {
  data: void
  status: 403
}
    
export type getDeleteuserAuthDeleteuserGetResponseSuccess = (getDeleteuserAuthDeleteuserGetResponse200) & {
  headers: Headers;
};
export type getDeleteuserAuthDeleteuserGetResponseError = (getDeleteuserAuthDeleteuserGetResponse403) & {
  headers: Headers;
};

export type getDeleteuserAuthDeleteuserGetResponse = (getDeleteuserAuthDeleteuserGetResponseSuccess | getDeleteuserAuthDeleteuserGetResponseError)

export const getGetDeleteuserAuthDeleteuserGetUrl = () => {


  

  return `https://flathub.org/api/v2/auth/deleteuser`
}

export const getDeleteuserAuthDeleteuserGet = async ( options?: RequestInit): Promise<getDeleteuserAuthDeleteuserGetResponse> => {
  
  const res = await fetch(getGetDeleteuserAuthDeleteuserGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDeleteuserAuthDeleteuserGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDeleteuserAuthDeleteuserGetResponse
}



/**
 * Clear the login state. This will then delete the user's account
and associated data. Unless there is an error.

The input to this should be of the form:

```json
{
    "token": "...",
}
```
 * @summary Do Deleteuser
 */
export type doDeleteuserAuthDeleteuserPostResponse200 = {
  data: DeleteUserResult
  status: 200
}

export type doDeleteuserAuthDeleteuserPostResponse400 = {
  data: void
  status: 400
}

export type doDeleteuserAuthDeleteuserPostResponse403 = {
  data: void
  status: 403
}

export type doDeleteuserAuthDeleteuserPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type doDeleteuserAuthDeleteuserPostResponseSuccess = (doDeleteuserAuthDeleteuserPostResponse200) & {
  headers: Headers;
};
export type doDeleteuserAuthDeleteuserPostResponseError = (doDeleteuserAuthDeleteuserPostResponse400 | doDeleteuserAuthDeleteuserPostResponse403 | doDeleteuserAuthDeleteuserPostResponse422) & {
  headers: Headers;
};

export type doDeleteuserAuthDeleteuserPostResponse = (doDeleteuserAuthDeleteuserPostResponseSuccess | doDeleteuserAuthDeleteuserPostResponseError)

export const getDoDeleteuserAuthDeleteuserPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/deleteuser`
}

export const doDeleteuserAuthDeleteuserPost = async (userDeleteRequest: UserDeleteRequest, options?: RequestInit): Promise<doDeleteuserAuthDeleteuserPostResponse> => {
  
  const res = await fetch(getDoDeleteuserAuthDeleteuserPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userDeleteRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: doDeleteuserAuthDeleteuserPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as doDeleteuserAuthDeleteuserPostResponse
}



/**
 * @summary Do Agree To Publisher Agreement
 */
export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse200 = {
  data: unknown
  status: 200
}

export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse403 = {
  data: void
  status: 403
}
    
export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseSuccess = (doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse200) & {
  headers: Headers;
};
export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseError = (doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse403) & {
  headers: Headers;
};

export type doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse = (doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseSuccess | doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponseError)

export const getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostUrl = () => {


  

  return `https://flathub.org/api/v2/auth/accept-publisher-agreement`
}

export const doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPost = async ( options?: RequestInit): Promise<doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse> => {
  
  const res = await fetch(getDoAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as doAgreeToPublisherAgreementAuthAcceptPublisherAgreementPostResponse
}



/**
 * Changes the user's default account, which determines which display name and email we use.
 * @summary Do Change Default Account
 */
export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse204 = {
  data: void
  status: 204
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse403 = {
  data: void
  status: 403
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse404 = {
  data: void
  status: 404
}

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponseSuccess = (doChangeDefaultAccountAuthChangeDefaultAccountPostResponse204) & {
  headers: Headers;
};
export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponseError = (doChangeDefaultAccountAuthChangeDefaultAccountPostResponse403 | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse404 | doChangeDefaultAccountAuthChangeDefaultAccountPostResponse422) & {
  headers: Headers;
};

export type doChangeDefaultAccountAuthChangeDefaultAccountPostResponse = (doChangeDefaultAccountAuthChangeDefaultAccountPostResponseSuccess | doChangeDefaultAccountAuthChangeDefaultAccountPostResponseError)

export const getDoChangeDefaultAccountAuthChangeDefaultAccountPostUrl = (params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/auth/change-default-account?${stringifiedParams}` : `https://flathub.org/api/v2/auth/change-default-account`
}

export const doChangeDefaultAccountAuthChangeDefaultAccountPost = async (params: DoChangeDefaultAccountAuthChangeDefaultAccountPostParams, options?: RequestInit): Promise<doChangeDefaultAccountAuthChangeDefaultAccountPostResponse> => {
  
  const res = await fetch(getDoChangeDefaultAccountAuthChangeDefaultAccountPostUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: doChangeDefaultAccountAuthChangeDefaultAccountPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as doChangeDefaultAccountAuthChangeDefaultAccountPostResponse
}



/**
 * Get a list of apps with unhandled moderation requests.
 * @summary Get Moderation Apps
 */
export type getModerationAppsModerationAppsGetResponse200 = {
  data: ModerationAppsResponse
  status: 200
}

export type getModerationAppsModerationAppsGetResponse401 = {
  data: void
  status: 401
}

export type getModerationAppsModerationAppsGetResponse403 = {
  data: void
  status: 403
}

export type getModerationAppsModerationAppsGetResponse422 = {
  data: void
  status: 422
}

export type getModerationAppsModerationAppsGetResponse500 = {
  data: void
  status: 500
}
    
export type getModerationAppsModerationAppsGetResponseSuccess = (getModerationAppsModerationAppsGetResponse200) & {
  headers: Headers;
};
export type getModerationAppsModerationAppsGetResponseError = (getModerationAppsModerationAppsGetResponse401 | getModerationAppsModerationAppsGetResponse403 | getModerationAppsModerationAppsGetResponse422 | getModerationAppsModerationAppsGetResponse500) & {
  headers: Headers;
};

export type getModerationAppsModerationAppsGetResponse = (getModerationAppsModerationAppsGetResponseSuccess | getModerationAppsModerationAppsGetResponseError)

export const getGetModerationAppsModerationAppsGetUrl = (params?: GetModerationAppsModerationAppsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/moderation/apps?${stringifiedParams}` : `https://flathub.org/api/v2/moderation/apps`
}

export const getModerationAppsModerationAppsGet = async (params?: GetModerationAppsModerationAppsGetParams, options?: RequestInit): Promise<getModerationAppsModerationAppsGetResponse> => {
  
  const res = await fetch(getGetModerationAppsModerationAppsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getModerationAppsModerationAppsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getModerationAppsModerationAppsGetResponse
}



/**
 * Get a list of moderation requests for an app.
 * @summary Get Moderation App
 */
export type getModerationAppModerationAppsAppIdGetResponse200 = {
  data: ModerationApp
  status: 200
}

export type getModerationAppModerationAppsAppIdGetResponse401 = {
  data: void
  status: 401
}

export type getModerationAppModerationAppsAppIdGetResponse403 = {
  data: void
  status: 403
}

export type getModerationAppModerationAppsAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getModerationAppModerationAppsAppIdGetResponse422 = {
  data: void
  status: 422
}

export type getModerationAppModerationAppsAppIdGetResponse500 = {
  data: void
  status: 500
}
    
export type getModerationAppModerationAppsAppIdGetResponseSuccess = (getModerationAppModerationAppsAppIdGetResponse200) & {
  headers: Headers;
};
export type getModerationAppModerationAppsAppIdGetResponseError = (getModerationAppModerationAppsAppIdGetResponse401 | getModerationAppModerationAppsAppIdGetResponse403 | getModerationAppModerationAppsAppIdGetResponse404 | getModerationAppModerationAppsAppIdGetResponse422 | getModerationAppModerationAppsAppIdGetResponse500) & {
  headers: Headers;
};

export type getModerationAppModerationAppsAppIdGetResponse = (getModerationAppModerationAppsAppIdGetResponseSuccess | getModerationAppModerationAppsAppIdGetResponseError)

export const getGetModerationAppModerationAppsAppIdGetUrl = (appId: string,
    params?: GetModerationAppModerationAppsAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/moderation/apps/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/moderation/apps/${appId}`
}

export const getModerationAppModerationAppsAppIdGet = async (appId: string,
    params?: GetModerationAppModerationAppsAppIdGetParams, options?: RequestInit): Promise<getModerationAppModerationAppsAppIdGetResponse> => {
  
  const res = await fetch(getGetModerationAppModerationAppsAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getModerationAppModerationAppsAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getModerationAppModerationAppsAppIdGetResponse
}



/**
 * @summary Submit Review Request
 */
export type submitReviewRequestModerationSubmitReviewRequestPostResponse200 = {
  data: ReviewRequestResponse
  status: 200
}

export type submitReviewRequestModerationSubmitReviewRequestPostResponse401 = {
  data: void
  status: 401
}

export type submitReviewRequestModerationSubmitReviewRequestPostResponse422 = {
  data: void
  status: 422
}

export type submitReviewRequestModerationSubmitReviewRequestPostResponse500 = {
  data: void
  status: 500
}
    
export type submitReviewRequestModerationSubmitReviewRequestPostResponseSuccess = (submitReviewRequestModerationSubmitReviewRequestPostResponse200) & {
  headers: Headers;
};
export type submitReviewRequestModerationSubmitReviewRequestPostResponseError = (submitReviewRequestModerationSubmitReviewRequestPostResponse401 | submitReviewRequestModerationSubmitReviewRequestPostResponse422 | submitReviewRequestModerationSubmitReviewRequestPostResponse500) & {
  headers: Headers;
};

export type submitReviewRequestModerationSubmitReviewRequestPostResponse = (submitReviewRequestModerationSubmitReviewRequestPostResponseSuccess | submitReviewRequestModerationSubmitReviewRequestPostResponseError)

export const getSubmitReviewRequestModerationSubmitReviewRequestPostUrl = () => {


  

  return `https://flathub.org/api/v2/moderation/submit_review_request`
}

export const submitReviewRequestModerationSubmitReviewRequestPost = async (reviewRequest: ReviewRequest, options?: RequestInit): Promise<submitReviewRequestModerationSubmitReviewRequestPostResponse> => {
  
  const res = await fetch(getSubmitReviewRequestModerationSubmitReviewRequestPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      reviewRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: submitReviewRequestModerationSubmitReviewRequestPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as submitReviewRequestModerationSubmitReviewRequestPostResponse
}



/**
 * Approve or reject the moderation request with a comment. If all requests for a job are approved, the job is
marked as successful in flat-manager.
 * @summary Submit Review
 */
export type submitReviewModerationRequestsIdReviewPostResponse200 = {
  data: ReviewResponse
  status: 200
}

export type submitReviewModerationRequestsIdReviewPostResponse401 = {
  data: void
  status: 401
}

export type submitReviewModerationRequestsIdReviewPostResponse403 = {
  data: void
  status: 403
}

export type submitReviewModerationRequestsIdReviewPostResponse404 = {
  data: void
  status: 404
}

export type submitReviewModerationRequestsIdReviewPostResponse422 = {
  data: void
  status: 422
}

export type submitReviewModerationRequestsIdReviewPostResponse500 = {
  data: void
  status: 500
}
    
export type submitReviewModerationRequestsIdReviewPostResponseSuccess = (submitReviewModerationRequestsIdReviewPostResponse200) & {
  headers: Headers;
};
export type submitReviewModerationRequestsIdReviewPostResponseError = (submitReviewModerationRequestsIdReviewPostResponse401 | submitReviewModerationRequestsIdReviewPostResponse403 | submitReviewModerationRequestsIdReviewPostResponse404 | submitReviewModerationRequestsIdReviewPostResponse422 | submitReviewModerationRequestsIdReviewPostResponse500) & {
  headers: Headers;
};

export type submitReviewModerationRequestsIdReviewPostResponse = (submitReviewModerationRequestsIdReviewPostResponseSuccess | submitReviewModerationRequestsIdReviewPostResponseError)

export const getSubmitReviewModerationRequestsIdReviewPostUrl = (id: number,) => {


  

  return `https://flathub.org/api/v2/moderation/requests/${id}/review`
}

export const submitReviewModerationRequestsIdReviewPost = async (id: number,
    review: Review, options?: RequestInit): Promise<submitReviewModerationRequestsIdReviewPostResponse> => {
  
  const res = await fetch(getSubmitReviewModerationRequestsIdReviewPostUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      review,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: submitReviewModerationRequestsIdReviewPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as submitReviewModerationRequestsIdReviewPostResponse
}



/**
 * Retrieve the wallet for the currently logged in user.

This will return a list of cards which the user has saved to their account.
 * @summary Get Walletinfo
 */
export type getWalletinfoWalletWalletinfoGetResponse200 = {
  data: WalletInfo
  status: 200
}

export type getWalletinfoWalletWalletinfoGetResponse401 = {
  data: void
  status: 401
}

export type getWalletinfoWalletWalletinfoGetResponse403 = {
  data: void
  status: 403
}

export type getWalletinfoWalletWalletinfoGetResponse500 = {
  data: void
  status: 500
}
    
export type getWalletinfoWalletWalletinfoGetResponseSuccess = (getWalletinfoWalletWalletinfoGetResponse200) & {
  headers: Headers;
};
export type getWalletinfoWalletWalletinfoGetResponseError = (getWalletinfoWalletWalletinfoGetResponse401 | getWalletinfoWalletWalletinfoGetResponse403 | getWalletinfoWalletWalletinfoGetResponse500) & {
  headers: Headers;
};

export type getWalletinfoWalletWalletinfoGetResponse = (getWalletinfoWalletWalletinfoGetResponseSuccess | getWalletinfoWalletWalletinfoGetResponseError)

export const getGetWalletinfoWalletWalletinfoGetUrl = () => {


  

  return `https://flathub.org/api/v2/wallet/walletinfo`
}

export const getWalletinfoWalletWalletinfoGet = async ( options?: RequestInit): Promise<getWalletinfoWalletWalletinfoGetResponse> => {
  
  const res = await fetch(getGetWalletinfoWalletWalletinfoGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getWalletinfoWalletWalletinfoGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getWalletinfoWalletWalletinfoGetResponse
}



/**
 * Remove a card from a user's wallet.

The provided information must exactly match a card as would be returned from the
wallet info endpoint.
 * @summary Post Removecard
 */
export type postRemovecardWalletRemovecardPostResponse200 = {
  data: unknown
  status: 200
}

export type postRemovecardWalletRemovecardPostResponse201 = {
  data: void
  status: 201
}

export type postRemovecardWalletRemovecardPostResponse401 = {
  data: void
  status: 401
}

export type postRemovecardWalletRemovecardPostResponse403 = {
  data: void
  status: 403
}

export type postRemovecardWalletRemovecardPostResponse422 = {
  data: void
  status: 422
}

export type postRemovecardWalletRemovecardPostResponse500 = {
  data: void
  status: 500
}
    
export type postRemovecardWalletRemovecardPostResponseSuccess = (postRemovecardWalletRemovecardPostResponse200 | postRemovecardWalletRemovecardPostResponse201) & {
  headers: Headers;
};
export type postRemovecardWalletRemovecardPostResponseError = (postRemovecardWalletRemovecardPostResponse401 | postRemovecardWalletRemovecardPostResponse403 | postRemovecardWalletRemovecardPostResponse422 | postRemovecardWalletRemovecardPostResponse500) & {
  headers: Headers;
};

export type postRemovecardWalletRemovecardPostResponse = (postRemovecardWalletRemovecardPostResponseSuccess | postRemovecardWalletRemovecardPostResponseError)

export const getPostRemovecardWalletRemovecardPostUrl = () => {


  

  return `https://flathub.org/api/v2/wallet/removecard`
}

export const postRemovecardWalletRemovecardPost = async (paymentCardInfo: PaymentCardInfo, options?: RequestInit): Promise<postRemovecardWalletRemovecardPostResponse> => {
  
  const res = await fetch(getPostRemovecardWalletRemovecardPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paymentCardInfo,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postRemovecardWalletRemovecardPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postRemovecardWalletRemovecardPostResponse
}



/**
 * Return a list of transactions associated with this user.

If anything goes wrong, an error will be returned, otherwise a list of transaction
summaries will be returned.
 * @summary Get Transactions
 */
export type getTransactionsWalletTransactionsGetResponse200 = {
  data: TransactionSummary[]
  status: 200
}

export type getTransactionsWalletTransactionsGetResponse401 = {
  data: void
  status: 401
}

export type getTransactionsWalletTransactionsGetResponse403 = {
  data: void
  status: 403
}

export type getTransactionsWalletTransactionsGetResponse422 = {
  data: void
  status: 422
}

export type getTransactionsWalletTransactionsGetResponse500 = {
  data: void
  status: 500
}
    
export type getTransactionsWalletTransactionsGetResponseSuccess = (getTransactionsWalletTransactionsGetResponse200) & {
  headers: Headers;
};
export type getTransactionsWalletTransactionsGetResponseError = (getTransactionsWalletTransactionsGetResponse401 | getTransactionsWalletTransactionsGetResponse403 | getTransactionsWalletTransactionsGetResponse422 | getTransactionsWalletTransactionsGetResponse500) & {
  headers: Headers;
};

export type getTransactionsWalletTransactionsGetResponse = (getTransactionsWalletTransactionsGetResponseSuccess | getTransactionsWalletTransactionsGetResponseError)

export const getGetTransactionsWalletTransactionsGetUrl = (params?: GetTransactionsWalletTransactionsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/wallet/transactions?${stringifiedParams}` : `https://flathub.org/api/v2/wallet/transactions`
}

export const getTransactionsWalletTransactionsGet = async (params?: GetTransactionsWalletTransactionsGetParams, options?: RequestInit): Promise<getTransactionsWalletTransactionsGetResponse> => {
  
  const res = await fetch(getGetTransactionsWalletTransactionsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTransactionsWalletTransactionsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTransactionsWalletTransactionsGetResponse
}



/**
 * Create a new transaction, return the ID.

If the passed in nascent transaction is valid, this will create a transaction and
return the ID of the newly created wallet, otherwise it'll return an error
 * @summary Create Transaction
 */
export type createTransactionWalletTransactionsPostResponse200 = {
  data: PostTransactionResponse
  status: 200
}

export type createTransactionWalletTransactionsPostResponse401 = {
  data: void
  status: 401
}

export type createTransactionWalletTransactionsPostResponse403 = {
  data: void
  status: 403
}

export type createTransactionWalletTransactionsPostResponse422 = {
  data: void
  status: 422
}

export type createTransactionWalletTransactionsPostResponse500 = {
  data: void
  status: 500
}
    
export type createTransactionWalletTransactionsPostResponseSuccess = (createTransactionWalletTransactionsPostResponse200) & {
  headers: Headers;
};
export type createTransactionWalletTransactionsPostResponseError = (createTransactionWalletTransactionsPostResponse401 | createTransactionWalletTransactionsPostResponse403 | createTransactionWalletTransactionsPostResponse422 | createTransactionWalletTransactionsPostResponse500) & {
  headers: Headers;
};

export type createTransactionWalletTransactionsPostResponse = (createTransactionWalletTransactionsPostResponseSuccess | createTransactionWalletTransactionsPostResponseError)

export const getCreateTransactionWalletTransactionsPostUrl = () => {


  

  return `https://flathub.org/api/v2/wallet/transactions`
}

export const createTransactionWalletTransactionsPost = async (nascentTransaction: NascentTransaction, options?: RequestInit): Promise<createTransactionWalletTransactionsPostResponse> => {
  
  const res = await fetch(getCreateTransactionWalletTransactionsPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      nascentTransaction,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createTransactionWalletTransactionsPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createTransactionWalletTransactionsPostResponse
}



/**
 * Retrieve a transaction by its ID

If the transaction ID is valid, and owned by the calling user, then this will
retrieve the whole transaction, including card details and disbursement information
if available.
 * @summary Get Transaction By Id
 */
export type getTransactionByIdWalletTransactionsTxnGetResponse200 = {
  data: Transaction
  status: 200
}

export type getTransactionByIdWalletTransactionsTxnGetResponse401 = {
  data: void
  status: 401
}

export type getTransactionByIdWalletTransactionsTxnGetResponse403 = {
  data: void
  status: 403
}

export type getTransactionByIdWalletTransactionsTxnGetResponse404 = {
  data: void
  status: 404
}

export type getTransactionByIdWalletTransactionsTxnGetResponse422 = {
  data: void
  status: 422
}

export type getTransactionByIdWalletTransactionsTxnGetResponse500 = {
  data: void
  status: 500
}
    
export type getTransactionByIdWalletTransactionsTxnGetResponseSuccess = (getTransactionByIdWalletTransactionsTxnGetResponse200) & {
  headers: Headers;
};
export type getTransactionByIdWalletTransactionsTxnGetResponseError = (getTransactionByIdWalletTransactionsTxnGetResponse401 | getTransactionByIdWalletTransactionsTxnGetResponse403 | getTransactionByIdWalletTransactionsTxnGetResponse404 | getTransactionByIdWalletTransactionsTxnGetResponse422 | getTransactionByIdWalletTransactionsTxnGetResponse500) & {
  headers: Headers;
};

export type getTransactionByIdWalletTransactionsTxnGetResponse = (getTransactionByIdWalletTransactionsTxnGetResponseSuccess | getTransactionByIdWalletTransactionsTxnGetResponseError)

export const getGetTransactionByIdWalletTransactionsTxnGetUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}`
}

export const getTransactionByIdWalletTransactionsTxnGet = async (txn: string, options?: RequestInit): Promise<getTransactionByIdWalletTransactionsTxnGetResponse> => {
  
  const res = await fetch(getGetTransactionByIdWalletTransactionsTxnGetUrl(txn),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTransactionByIdWalletTransactionsTxnGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTransactionByIdWalletTransactionsTxnGetResponse
}



/**
 * Set the card associated with a transaction.

The posted card must exactly match one of the cards returned by the wallet
info endpoint or else the update may not succeed
 * @summary Set Transaction Card
 */
export type setTransactionCardWalletTransactionsTxnSetcardPostResponse200 = {
  data: unknown
  status: 200
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse401 = {
  data: void
  status: 401
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse403 = {
  data: void
  status: 403
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse404 = {
  data: void
  status: 404
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse422 = {
  data: void
  status: 422
}

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse500 = {
  data: void
  status: 500
}
    
export type setTransactionCardWalletTransactionsTxnSetcardPostResponseSuccess = (setTransactionCardWalletTransactionsTxnSetcardPostResponse200) & {
  headers: Headers;
};
export type setTransactionCardWalletTransactionsTxnSetcardPostResponseError = (setTransactionCardWalletTransactionsTxnSetcardPostResponse401 | setTransactionCardWalletTransactionsTxnSetcardPostResponse403 | setTransactionCardWalletTransactionsTxnSetcardPostResponse404 | setTransactionCardWalletTransactionsTxnSetcardPostResponse422 | setTransactionCardWalletTransactionsTxnSetcardPostResponse500) & {
  headers: Headers;
};

export type setTransactionCardWalletTransactionsTxnSetcardPostResponse = (setTransactionCardWalletTransactionsTxnSetcardPostResponseSuccess | setTransactionCardWalletTransactionsTxnSetcardPostResponseError)

export const getSetTransactionCardWalletTransactionsTxnSetcardPostUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}/setcard`
}

export const setTransactionCardWalletTransactionsTxnSetcardPost = async (txn: string,
    paymentCardInfo: PaymentCardInfo, options?: RequestInit): Promise<setTransactionCardWalletTransactionsTxnSetcardPostResponse> => {
  
  const res = await fetch(getSetTransactionCardWalletTransactionsTxnSetcardPostUrl(txn),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paymentCardInfo,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setTransactionCardWalletTransactionsTxnSetcardPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setTransactionCardWalletTransactionsTxnSetcardPostResponse
}



/**
 * Cancel a transaction in the `new` or `retry` states.

Note that this may actually not cancel if a webhook fires asynchronously
and updates the transaction.  This API will not attempt to prevent stripe
payments from completing.
 * @summary Cancel Transaction
 */
export type cancelTransactionWalletTransactionsTxnCancelPostResponse200 = {
  data: unknown
  status: 200
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse201 = {
  data: void
  status: 201
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse401 = {
  data: void
  status: 401
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse403 = {
  data: void
  status: 403
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse404 = {
  data: void
  status: 404
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse422 = {
  data: void
  status: 422
}

export type cancelTransactionWalletTransactionsTxnCancelPostResponse500 = {
  data: void
  status: 500
}
    
export type cancelTransactionWalletTransactionsTxnCancelPostResponseSuccess = (cancelTransactionWalletTransactionsTxnCancelPostResponse200 | cancelTransactionWalletTransactionsTxnCancelPostResponse201) & {
  headers: Headers;
};
export type cancelTransactionWalletTransactionsTxnCancelPostResponseError = (cancelTransactionWalletTransactionsTxnCancelPostResponse401 | cancelTransactionWalletTransactionsTxnCancelPostResponse403 | cancelTransactionWalletTransactionsTxnCancelPostResponse404 | cancelTransactionWalletTransactionsTxnCancelPostResponse422 | cancelTransactionWalletTransactionsTxnCancelPostResponse500) & {
  headers: Headers;
};

export type cancelTransactionWalletTransactionsTxnCancelPostResponse = (cancelTransactionWalletTransactionsTxnCancelPostResponseSuccess | cancelTransactionWalletTransactionsTxnCancelPostResponseError)

export const getCancelTransactionWalletTransactionsTxnCancelPostUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}/cancel`
}

export const cancelTransactionWalletTransactionsTxnCancelPost = async (txn: string, options?: RequestInit): Promise<cancelTransactionWalletTransactionsTxnCancelPostResponse> => {
  
  const res = await fetch(getCancelTransactionWalletTransactionsTxnCancelPostUrl(txn),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: cancelTransactionWalletTransactionsTxnCancelPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as cancelTransactionWalletTransactionsTxnCancelPostResponse
}



/**
 * Return the stripe public key to use in the frontend.  Since this is not
considered secret, we don't need a login or anything for this
 * @summary Get Stripedata
 */
export type getStripedataWalletStripedataGetResponse200 = {
  data: StripeKeys
  status: 200
}

export type getStripedataWalletStripedataGetResponse500 = {
  data: void
  status: 500
}
    
export type getStripedataWalletStripedataGetResponseSuccess = (getStripedataWalletStripedataGetResponse200) & {
  headers: Headers;
};
export type getStripedataWalletStripedataGetResponseError = (getStripedataWalletStripedataGetResponse500) & {
  headers: Headers;
};

export type getStripedataWalletStripedataGetResponse = (getStripedataWalletStripedataGetResponseSuccess | getStripedataWalletStripedataGetResponseError)

export const getGetStripedataWalletStripedataGetUrl = () => {


  

  return `https://flathub.org/api/v2/wallet/stripedata`
}

export const getStripedataWalletStripedataGet = async ( options?: RequestInit): Promise<getStripedataWalletStripedataGetResponse> => {
  
  const res = await fetch(getGetStripedataWalletStripedataGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStripedataWalletStripedataGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStripedataWalletStripedataGetResponse
}



/**
 * Return the Stripe data associated with the given transaction.

This is only applicable to transactions in the `new` or `retry` state and
will only work for transactions which *are* Stripe transactions.
 * @summary Get Txn Stripedata
 */
export type getTxnStripedataWalletTransactionsTxnStripeGetResponse200 = {
  data: TransactionStripeData
  status: 200
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse401 = {
  data: void
  status: 401
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse403 = {
  data: void
  status: 403
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse404 = {
  data: void
  status: 404
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse422 = {
  data: void
  status: 422
}

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse500 = {
  data: void
  status: 500
}
    
export type getTxnStripedataWalletTransactionsTxnStripeGetResponseSuccess = (getTxnStripedataWalletTransactionsTxnStripeGetResponse200) & {
  headers: Headers;
};
export type getTxnStripedataWalletTransactionsTxnStripeGetResponseError = (getTxnStripedataWalletTransactionsTxnStripeGetResponse401 | getTxnStripedataWalletTransactionsTxnStripeGetResponse403 | getTxnStripedataWalletTransactionsTxnStripeGetResponse404 | getTxnStripedataWalletTransactionsTxnStripeGetResponse422 | getTxnStripedataWalletTransactionsTxnStripeGetResponse500) & {
  headers: Headers;
};

export type getTxnStripedataWalletTransactionsTxnStripeGetResponse = (getTxnStripedataWalletTransactionsTxnStripeGetResponseSuccess | getTxnStripedataWalletTransactionsTxnStripeGetResponseError)

export const getGetTxnStripedataWalletTransactionsTxnStripeGetUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}/stripe`
}

export const getTxnStripedataWalletTransactionsTxnStripeGet = async (txn: string, options?: RequestInit): Promise<getTxnStripedataWalletTransactionsTxnStripeGetResponse> => {
  
  const res = await fetch(getGetTxnStripedataWalletTransactionsTxnStripeGetUrl(txn),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTxnStripedataWalletTransactionsTxnStripeGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTxnStripedataWalletTransactionsTxnStripeGetResponse
}



/**
 * Set the save-card status.

This is only applicable to transactions in the `new` or `retry` state
and will only work for transactions which are backed by stripe or similar.

If the `save_card` parameter is null, then the card will not be saved,
otherwise it will be saved.  If it's set to `off_session` then an attempt
will be made to create a saved method which can be used without the user
re-authenticating
 * @summary Set Savecard
 */
export type setSavecardWalletTransactionsTxnSavecardPostResponse200 = {
  data: unknown
  status: 200
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse201 = {
  data: void
  status: 201
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse401 = {
  data: void
  status: 401
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse403 = {
  data: void
  status: 403
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse404 = {
  data: void
  status: 404
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse422 = {
  data: void
  status: 422
}

export type setSavecardWalletTransactionsTxnSavecardPostResponse500 = {
  data: void
  status: 500
}
    
export type setSavecardWalletTransactionsTxnSavecardPostResponseSuccess = (setSavecardWalletTransactionsTxnSavecardPostResponse200 | setSavecardWalletTransactionsTxnSavecardPostResponse201) & {
  headers: Headers;
};
export type setSavecardWalletTransactionsTxnSavecardPostResponseError = (setSavecardWalletTransactionsTxnSavecardPostResponse401 | setSavecardWalletTransactionsTxnSavecardPostResponse403 | setSavecardWalletTransactionsTxnSavecardPostResponse404 | setSavecardWalletTransactionsTxnSavecardPostResponse422 | setSavecardWalletTransactionsTxnSavecardPostResponse500) & {
  headers: Headers;
};

export type setSavecardWalletTransactionsTxnSavecardPostResponse = (setSavecardWalletTransactionsTxnSavecardPostResponseSuccess | setSavecardWalletTransactionsTxnSavecardPostResponseError)

export const getSetSavecardWalletTransactionsTxnSavecardPostUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}/savecard`
}

export const setSavecardWalletTransactionsTxnSavecardPost = async (txn: string,
    transactionSaveCard: TransactionSaveCard, options?: RequestInit): Promise<setSavecardWalletTransactionsTxnSavecardPostResponse> => {
  
  const res = await fetch(getSetSavecardWalletTransactionsTxnSavecardPostUrl(txn),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      transactionSaveCard,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setSavecardWalletTransactionsTxnSavecardPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setSavecardWalletTransactionsTxnSavecardPostResponse
}



/**
 * Set the transaction as 'pending' so that we can recover if Stripe
flows don't quite work (e.g. webhook goes missing)
 * @summary Set Pending
 */
export type setPendingWalletTransactionsTxnSetpendingPostResponse200 = {
  data: unknown
  status: 200
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse201 = {
  data: void
  status: 201
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse401 = {
  data: void
  status: 401
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse403 = {
  data: void
  status: 403
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse404 = {
  data: void
  status: 404
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse422 = {
  data: void
  status: 422
}

export type setPendingWalletTransactionsTxnSetpendingPostResponse500 = {
  data: void
  status: 500
}
    
export type setPendingWalletTransactionsTxnSetpendingPostResponseSuccess = (setPendingWalletTransactionsTxnSetpendingPostResponse200 | setPendingWalletTransactionsTxnSetpendingPostResponse201) & {
  headers: Headers;
};
export type setPendingWalletTransactionsTxnSetpendingPostResponseError = (setPendingWalletTransactionsTxnSetpendingPostResponse401 | setPendingWalletTransactionsTxnSetpendingPostResponse403 | setPendingWalletTransactionsTxnSetpendingPostResponse404 | setPendingWalletTransactionsTxnSetpendingPostResponse422 | setPendingWalletTransactionsTxnSetpendingPostResponse500) & {
  headers: Headers;
};

export type setPendingWalletTransactionsTxnSetpendingPostResponse = (setPendingWalletTransactionsTxnSetpendingPostResponseSuccess | setPendingWalletTransactionsTxnSetpendingPostResponseError)

export const getSetPendingWalletTransactionsTxnSetpendingPostUrl = (txn: string,) => {


  

  return `https://flathub.org/api/v2/wallet/transactions/${txn}/setpending`
}

export const setPendingWalletTransactionsTxnSetpendingPost = async (txn: string, options?: RequestInit): Promise<setPendingWalletTransactionsTxnSetpendingPostResponse> => {
  
  const res = await fetch(getSetPendingWalletTransactionsTxnSetpendingPostUrl(txn),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setPendingWalletTransactionsTxnSetpendingPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setPendingWalletTransactionsTxnSetpendingPostResponse
}



/**
 * This endpoint is intended to deal with webhooks coming back from payment
mechanisms etc.  It exists only for the deployed wallet, so its name
will vary with the deployed wallet kind.

The exact form of the content posted to the webhook will vary from wallet
kind to wallet kind.
 * @summary Webhook
 */
export type webhookWalletWebhookStripePostResponse200 = {
  data: unknown
  status: 200
}

export type webhookWalletWebhookStripePostResponse400 = {
  data: void
  status: 400
}

export type webhookWalletWebhookStripePostResponse500 = {
  data: void
  status: 500
}
    
export type webhookWalletWebhookStripePostResponseSuccess = (webhookWalletWebhookStripePostResponse200) & {
  headers: Headers;
};
export type webhookWalletWebhookStripePostResponseError = (webhookWalletWebhookStripePostResponse400 | webhookWalletWebhookStripePostResponse500) & {
  headers: Headers;
};

export type webhookWalletWebhookStripePostResponse = (webhookWalletWebhookStripePostResponseSuccess | webhookWalletWebhookStripePostResponseError)

export const getWebhookWalletWebhookStripePostUrl = () => {


  

  return `https://flathub.org/api/v2/wallet/webhook/stripe`
}

export const webhookWalletWebhookStripePost = async ( options?: RequestInit): Promise<webhookWalletWebhookStripePostResponse> => {
  
  const res = await fetch(getWebhookWalletWebhookStripePostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: webhookWalletWebhookStripePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as webhookWalletWebhookStripePostResponse
}



/**
 * Retrieve the vending status of the logged in user.

This will return `201` if the logged in user has never begun the onboarding
flow to be a vendor on Flathub.
 * @summary Status
 */
export type statusVendingStatusGetResponse200 = {
  data: VendingStatus
  status: 200
}

export type statusVendingStatusGetResponse201 = {
  data: void
  status: 201
}

export type statusVendingStatusGetResponse401 = {
  data: void
  status: 401
}

export type statusVendingStatusGetResponse403 = {
  data: void
  status: 403
}

export type statusVendingStatusGetResponse500 = {
  data: void
  status: 500
}
    
export type statusVendingStatusGetResponseSuccess = (statusVendingStatusGetResponse200 | statusVendingStatusGetResponse201) & {
  headers: Headers;
};
export type statusVendingStatusGetResponseError = (statusVendingStatusGetResponse401 | statusVendingStatusGetResponse403 | statusVendingStatusGetResponse500) & {
  headers: Headers;
};

export type statusVendingStatusGetResponse = (statusVendingStatusGetResponseSuccess | statusVendingStatusGetResponseError)

export const getStatusVendingStatusGetUrl = () => {


  

  return `https://flathub.org/api/v2/vending/status`
}

export const statusVendingStatusGet = async ( options?: RequestInit): Promise<statusVendingStatusGetResponse> => {
  
  const res = await fetch(getStatusVendingStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: statusVendingStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as statusVendingStatusGetResponse
}



/**
 * Start or continue the onboarding process.
 * @summary Start Onboarding
 */
export type startOnboardingVendingStatusOnboardingPostResponse200 = {
  data: VendingRedirect
  status: 200
}

export type startOnboardingVendingStatusOnboardingPostResponse401 = {
  data: void
  status: 401
}

export type startOnboardingVendingStatusOnboardingPostResponse403 = {
  data: void
  status: 403
}

export type startOnboardingVendingStatusOnboardingPostResponse422 = {
  data: void
  status: 422
}

export type startOnboardingVendingStatusOnboardingPostResponse500 = {
  data: void
  status: 500
}
    
export type startOnboardingVendingStatusOnboardingPostResponseSuccess = (startOnboardingVendingStatusOnboardingPostResponse200) & {
  headers: Headers;
};
export type startOnboardingVendingStatusOnboardingPostResponseError = (startOnboardingVendingStatusOnboardingPostResponse401 | startOnboardingVendingStatusOnboardingPostResponse403 | startOnboardingVendingStatusOnboardingPostResponse422 | startOnboardingVendingStatusOnboardingPostResponse500) & {
  headers: Headers;
};

export type startOnboardingVendingStatusOnboardingPostResponse = (startOnboardingVendingStatusOnboardingPostResponseSuccess | startOnboardingVendingStatusOnboardingPostResponseError)

export const getStartOnboardingVendingStatusOnboardingPostUrl = () => {


  

  return `https://flathub.org/api/v2/vending/status/onboarding`
}

export const startOnboardingVendingStatusOnboardingPost = async (vendingOnboardingRequest: VendingOnboardingRequest, options?: RequestInit): Promise<startOnboardingVendingStatusOnboardingPostResponse> => {
  
  const res = await fetch(getStartOnboardingVendingStatusOnboardingPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendingOnboardingRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: startOnboardingVendingStatusOnboardingPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as startOnboardingVendingStatusOnboardingPostResponse
}



/**
 * Retrieve a link to the logged in user's Stripe express dashboard.

The user must be logged in and must have onboarded.
 * @summary Get Dashboard Link
 */
export type getDashboardLinkVendingStatusDashboardlinkGetResponse200 = {
  data: VendingRedirect
  status: 200
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse401 = {
  data: void
  status: 401
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse403 = {
  data: void
  status: 403
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse404 = {
  data: void
  status: 404
}

export type getDashboardLinkVendingStatusDashboardlinkGetResponse500 = {
  data: void
  status: 500
}
    
export type getDashboardLinkVendingStatusDashboardlinkGetResponseSuccess = (getDashboardLinkVendingStatusDashboardlinkGetResponse200) & {
  headers: Headers;
};
export type getDashboardLinkVendingStatusDashboardlinkGetResponseError = (getDashboardLinkVendingStatusDashboardlinkGetResponse401 | getDashboardLinkVendingStatusDashboardlinkGetResponse403 | getDashboardLinkVendingStatusDashboardlinkGetResponse404 | getDashboardLinkVendingStatusDashboardlinkGetResponse500) & {
  headers: Headers;
};

export type getDashboardLinkVendingStatusDashboardlinkGetResponse = (getDashboardLinkVendingStatusDashboardlinkGetResponseSuccess | getDashboardLinkVendingStatusDashboardlinkGetResponseError)

export const getGetDashboardLinkVendingStatusDashboardlinkGetUrl = () => {


  

  return `https://flathub.org/api/v2/vending/status/dashboardlink`
}

export const getDashboardLinkVendingStatusDashboardlinkGet = async ( options?: RequestInit): Promise<getDashboardLinkVendingStatusDashboardlinkGetResponse> => {
  
  const res = await fetch(getGetDashboardLinkVendingStatusDashboardlinkGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDashboardLinkVendingStatusDashboardlinkGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDashboardLinkVendingStatusDashboardlinkGetResponse
}



/**
 * Retrieve the configuration values needed to calculate application
vending splits client-side.

Configuration includes:
- Fee values
- Platform values
 * @summary Get Global Vending Config
 */
export type getGlobalVendingConfigVendingConfigGetResponse200 = {
  data: VendingConfig
  status: 200
}

export type getGlobalVendingConfigVendingConfigGetResponse500 = {
  data: void
  status: 500
}
    
export type getGlobalVendingConfigVendingConfigGetResponseSuccess = (getGlobalVendingConfigVendingConfigGetResponse200) & {
  headers: Headers;
};
export type getGlobalVendingConfigVendingConfigGetResponseError = (getGlobalVendingConfigVendingConfigGetResponse500) & {
  headers: Headers;
};

export type getGlobalVendingConfigVendingConfigGetResponse = (getGlobalVendingConfigVendingConfigGetResponseSuccess | getGlobalVendingConfigVendingConfigGetResponseError)

export const getGetGlobalVendingConfigVendingConfigGetUrl = () => {


  

  return `https://flathub.org/api/v2/vending/config`
}

export const getGlobalVendingConfigVendingConfigGet = async ( options?: RequestInit): Promise<getGlobalVendingConfigVendingConfigGetResponse> => {
  
  const res = await fetch(getGetGlobalVendingConfigVendingConfigGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getGlobalVendingConfigVendingConfigGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getGlobalVendingConfigVendingConfigGetResponse
}



/**
 * Retrieve the vending status for a given application.
 * @summary Get App Vending Setup
 */
export type getAppVendingSetupVendingappAppIdSetupGetResponse200 = {
  data: VendingSetup
  status: 200
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse401 = {
  data: void
  status: 401
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse403 = {
  data: void
  status: 403
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse404 = {
  data: void
  status: 404
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse422 = {
  data: void
  status: 422
}

export type getAppVendingSetupVendingappAppIdSetupGetResponse500 = {
  data: void
  status: 500
}
    
export type getAppVendingSetupVendingappAppIdSetupGetResponseSuccess = (getAppVendingSetupVendingappAppIdSetupGetResponse200) & {
  headers: Headers;
};
export type getAppVendingSetupVendingappAppIdSetupGetResponseError = (getAppVendingSetupVendingappAppIdSetupGetResponse401 | getAppVendingSetupVendingappAppIdSetupGetResponse403 | getAppVendingSetupVendingappAppIdSetupGetResponse404 | getAppVendingSetupVendingappAppIdSetupGetResponse422 | getAppVendingSetupVendingappAppIdSetupGetResponse500) & {
  headers: Headers;
};

export type getAppVendingSetupVendingappAppIdSetupGetResponse = (getAppVendingSetupVendingappAppIdSetupGetResponseSuccess | getAppVendingSetupVendingappAppIdSetupGetResponseError)

export const getGetAppVendingSetupVendingappAppIdSetupGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/setup`
}

export const getAppVendingSetupVendingappAppIdSetupGet = async (appId: string, options?: RequestInit): Promise<getAppVendingSetupVendingappAppIdSetupGetResponse> => {
  
  const res = await fetch(getGetAppVendingSetupVendingappAppIdSetupGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppVendingSetupVendingappAppIdSetupGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppVendingSetupVendingappAppIdSetupGetResponse
}



/**
 * Create/update the vending status for a given application.  Returns an error
if the appid is not known, or if it's already set up for vending with a
user other than the one calling this API.

If you do not have the right to set the vending status for this application
then you will also be refused.

In addition, if any of the currency or amount values constraints are violated
then you will get an error
 * @summary Post App Vending Setup
 */
export type postAppVendingSetupVendingappAppIdSetupPostResponse200 = {
  data: VendingSetup
  status: 200
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse401 = {
  data: void
  status: 401
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse403 = {
  data: void
  status: 403
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse404 = {
  data: void
  status: 404
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse422 = {
  data: void
  status: 422
}

export type postAppVendingSetupVendingappAppIdSetupPostResponse500 = {
  data: void
  status: 500
}
    
export type postAppVendingSetupVendingappAppIdSetupPostResponseSuccess = (postAppVendingSetupVendingappAppIdSetupPostResponse200) & {
  headers: Headers;
};
export type postAppVendingSetupVendingappAppIdSetupPostResponseError = (postAppVendingSetupVendingappAppIdSetupPostResponse401 | postAppVendingSetupVendingappAppIdSetupPostResponse403 | postAppVendingSetupVendingappAppIdSetupPostResponse404 | postAppVendingSetupVendingappAppIdSetupPostResponse422 | postAppVendingSetupVendingappAppIdSetupPostResponse500) & {
  headers: Headers;
};

export type postAppVendingSetupVendingappAppIdSetupPostResponse = (postAppVendingSetupVendingappAppIdSetupPostResponseSuccess | postAppVendingSetupVendingappAppIdSetupPostResponseError)

export const getPostAppVendingSetupVendingappAppIdSetupPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/setup`
}

export const postAppVendingSetupVendingappAppIdSetupPost = async (appId: string,
    vendingSetupRequest: VendingSetupRequest, options?: RequestInit): Promise<postAppVendingSetupVendingappAppIdSetupPostResponse> => {
  
  const res = await fetch(getPostAppVendingSetupVendingappAppIdSetupPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      vendingSetupRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postAppVendingSetupVendingappAppIdSetupPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postAppVendingSetupVendingappAppIdSetupPostResponse
}



/**
 * Construct a transaction for the given application with the proposed payment.
If the proposed payment is unacceptable then an error will be returned.
If the user is not logged in, then an error will be returned.

Otherwise a transaction will be created and the information about it will be
returned in the output of the call.
 * @summary Post App Vending Status
 */
export type postAppVendingStatusVendingappAppIdPostResponse200 = {
  data: VendingOutput
  status: 200
}

export type postAppVendingStatusVendingappAppIdPostResponse401 = {
  data: void
  status: 401
}

export type postAppVendingStatusVendingappAppIdPostResponse403 = {
  data: void
  status: 403
}

export type postAppVendingStatusVendingappAppIdPostResponse404 = {
  data: void
  status: 404
}

export type postAppVendingStatusVendingappAppIdPostResponse422 = {
  data: void
  status: 422
}

export type postAppVendingStatusVendingappAppIdPostResponse500 = {
  data: void
  status: 500
}
    
export type postAppVendingStatusVendingappAppIdPostResponseSuccess = (postAppVendingStatusVendingappAppIdPostResponse200) & {
  headers: Headers;
};
export type postAppVendingStatusVendingappAppIdPostResponseError = (postAppVendingStatusVendingappAppIdPostResponse401 | postAppVendingStatusVendingappAppIdPostResponse403 | postAppVendingStatusVendingappAppIdPostResponse404 | postAppVendingStatusVendingappAppIdPostResponse422 | postAppVendingStatusVendingappAppIdPostResponse500) & {
  headers: Headers;
};

export type postAppVendingStatusVendingappAppIdPostResponse = (postAppVendingStatusVendingappAppIdPostResponseSuccess | postAppVendingStatusVendingappAppIdPostResponseError)

export const getPostAppVendingStatusVendingappAppIdPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}`
}

export const postAppVendingStatusVendingappAppIdPost = async (appId: string,
    proposedPayment: ProposedPayment, options?: RequestInit): Promise<postAppVendingStatusVendingappAppIdPostResponse> => {
  
  const res = await fetch(getPostAppVendingStatusVendingappAppIdPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      proposedPayment,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: postAppVendingStatusVendingappAppIdPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as postAppVendingStatusVendingappAppIdPostResponse
}



/**
 * Retrieve the redeemable tokens for the given application.

The caller must have control of the app at some level

For now, there is no pagination or filtering, all tokens will be returned
 * @summary Get Redeemable Tokens
 */
export type getRedeemableTokensVendingappAppIdTokensGetResponse200 = {
  data: TokenList
  status: 200
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse401 = {
  data: void
  status: 401
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse403 = {
  data: void
  status: 403
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse404 = {
  data: void
  status: 404
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse422 = {
  data: void
  status: 422
}

export type getRedeemableTokensVendingappAppIdTokensGetResponse500 = {
  data: void
  status: 500
}
    
export type getRedeemableTokensVendingappAppIdTokensGetResponseSuccess = (getRedeemableTokensVendingappAppIdTokensGetResponse200) & {
  headers: Headers;
};
export type getRedeemableTokensVendingappAppIdTokensGetResponseError = (getRedeemableTokensVendingappAppIdTokensGetResponse401 | getRedeemableTokensVendingappAppIdTokensGetResponse403 | getRedeemableTokensVendingappAppIdTokensGetResponse404 | getRedeemableTokensVendingappAppIdTokensGetResponse422 | getRedeemableTokensVendingappAppIdTokensGetResponse500) & {
  headers: Headers;
};

export type getRedeemableTokensVendingappAppIdTokensGetResponse = (getRedeemableTokensVendingappAppIdTokensGetResponseSuccess | getRedeemableTokensVendingappAppIdTokensGetResponseError)

export const getGetRedeemableTokensVendingappAppIdTokensGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/tokens`
}

export const getRedeemableTokensVendingappAppIdTokensGet = async (appId: string, options?: RequestInit): Promise<getRedeemableTokensVendingappAppIdTokensGetResponse> => {
  
  const res = await fetch(getGetRedeemableTokensVendingappAppIdTokensGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRedeemableTokensVendingappAppIdTokensGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRedeemableTokensVendingappAppIdTokensGetResponse
}



/**
 * Create some tokens for the given appid.

The calling user must own the vending config for this application
 * @summary Create Tokens
 */
export type createTokensVendingappAppIdTokensPostResponse200 = {
  data: TokenModel[]
  status: 200
}

export type createTokensVendingappAppIdTokensPostResponse401 = {
  data: void
  status: 401
}

export type createTokensVendingappAppIdTokensPostResponse403 = {
  data: void
  status: 403
}

export type createTokensVendingappAppIdTokensPostResponse404 = {
  data: void
  status: 404
}

export type createTokensVendingappAppIdTokensPostResponse422 = {
  data: void
  status: 422
}

export type createTokensVendingappAppIdTokensPostResponse500 = {
  data: void
  status: 500
}
    
export type createTokensVendingappAppIdTokensPostResponseSuccess = (createTokensVendingappAppIdTokensPostResponse200) & {
  headers: Headers;
};
export type createTokensVendingappAppIdTokensPostResponseError = (createTokensVendingappAppIdTokensPostResponse401 | createTokensVendingappAppIdTokensPostResponse403 | createTokensVendingappAppIdTokensPostResponse404 | createTokensVendingappAppIdTokensPostResponse422 | createTokensVendingappAppIdTokensPostResponse500) & {
  headers: Headers;
};

export type createTokensVendingappAppIdTokensPostResponse = (createTokensVendingappAppIdTokensPostResponseSuccess | createTokensVendingappAppIdTokensPostResponseError)

export const getCreateTokensVendingappAppIdTokensPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/tokens`
}

export const createTokensVendingappAppIdTokensPost = async (appId: string,
    createTokensVendingappAppIdTokensPostBody: string[], options?: RequestInit): Promise<createTokensVendingappAppIdTokensPostResponse> => {
  
  const res = await fetch(getCreateTokensVendingappAppIdTokensPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTokensVendingappAppIdTokensPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createTokensVendingappAppIdTokensPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createTokensVendingappAppIdTokensPostResponse
}



/**
 * Cancel a set of tokens
 * @summary Cancel Tokens
 */
export type cancelTokensVendingappAppIdTokensCancelPostResponse200 = {
  data: TokenCancellation[]
  status: 200
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse401 = {
  data: void
  status: 401
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse403 = {
  data: void
  status: 403
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse404 = {
  data: void
  status: 404
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse422 = {
  data: void
  status: 422
}

export type cancelTokensVendingappAppIdTokensCancelPostResponse500 = {
  data: void
  status: 500
}
    
export type cancelTokensVendingappAppIdTokensCancelPostResponseSuccess = (cancelTokensVendingappAppIdTokensCancelPostResponse200) & {
  headers: Headers;
};
export type cancelTokensVendingappAppIdTokensCancelPostResponseError = (cancelTokensVendingappAppIdTokensCancelPostResponse401 | cancelTokensVendingappAppIdTokensCancelPostResponse403 | cancelTokensVendingappAppIdTokensCancelPostResponse404 | cancelTokensVendingappAppIdTokensCancelPostResponse422 | cancelTokensVendingappAppIdTokensCancelPostResponse500) & {
  headers: Headers;
};

export type cancelTokensVendingappAppIdTokensCancelPostResponse = (cancelTokensVendingappAppIdTokensCancelPostResponseSuccess | cancelTokensVendingappAppIdTokensCancelPostResponseError)

export const getCancelTokensVendingappAppIdTokensCancelPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/tokens/cancel`
}

export const cancelTokensVendingappAppIdTokensCancelPost = async (appId: string,
    cancelTokensVendingappAppIdTokensCancelPostBody: string[], options?: RequestInit): Promise<cancelTokensVendingappAppIdTokensCancelPostResponse> => {
  
  const res = await fetch(getCancelTokensVendingappAppIdTokensCancelPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cancelTokensVendingappAppIdTokensCancelPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: cancelTokensVendingappAppIdTokensCancelPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as cancelTokensVendingappAppIdTokensCancelPostResponse
}



/**
 * This redeems the given token for the logged in user.

If the logged in user already owns the app then the token will not be redeemed
 * @summary Redeem Token
 */
export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse200 = {
  data: RedemptionResult
  status: 200
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse401 = {
  data: void
  status: 401
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse403 = {
  data: void
  status: 403
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse404 = {
  data: void
  status: 404
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse422 = {
  data: void
  status: 422
}

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse500 = {
  data: void
  status: 500
}
    
export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponseSuccess = (redeemTokenVendingappAppIdTokensRedeemTokenPostResponse200) & {
  headers: Headers;
};
export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponseError = (redeemTokenVendingappAppIdTokensRedeemTokenPostResponse401 | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse403 | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse404 | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse422 | redeemTokenVendingappAppIdTokensRedeemTokenPostResponse500) & {
  headers: Headers;
};

export type redeemTokenVendingappAppIdTokensRedeemTokenPostResponse = (redeemTokenVendingappAppIdTokensRedeemTokenPostResponseSuccess | redeemTokenVendingappAppIdTokensRedeemTokenPostResponseError)

export const getRedeemTokenVendingappAppIdTokensRedeemTokenPostUrl = (appId: string,
    token: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/tokens/redeem/${token}`
}

export const redeemTokenVendingappAppIdTokensRedeemTokenPost = async (appId: string,
    token: string, options?: RequestInit): Promise<redeemTokenVendingappAppIdTokensRedeemTokenPostResponse> => {
  
  const res = await fetch(getRedeemTokenVendingappAppIdTokensRedeemTokenPostUrl(appId,token),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: redeemTokenVendingappAppIdTokensRedeemTokenPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as redeemTokenVendingappAppIdTokensRedeemTokenPostResponse
}



/**
 * This determines the vending info for the app and returns it
 * @summary App Info
 */
export type appInfoVendingappAppIdInfoGetResponse200 = {
  data: VendingApplicationInformation
  status: 200
}

export type appInfoVendingappAppIdInfoGetResponse401 = {
  data: void
  status: 401
}

export type appInfoVendingappAppIdInfoGetResponse404 = {
  data: void
  status: 404
}

export type appInfoVendingappAppIdInfoGetResponse422 = {
  data: void
  status: 422
}

export type appInfoVendingappAppIdInfoGetResponse500 = {
  data: void
  status: 500
}
    
export type appInfoVendingappAppIdInfoGetResponseSuccess = (appInfoVendingappAppIdInfoGetResponse200) & {
  headers: Headers;
};
export type appInfoVendingappAppIdInfoGetResponseError = (appInfoVendingappAppIdInfoGetResponse401 | appInfoVendingappAppIdInfoGetResponse404 | appInfoVendingappAppIdInfoGetResponse422 | appInfoVendingappAppIdInfoGetResponse500) & {
  headers: Headers;
};

export type appInfoVendingappAppIdInfoGetResponse = (appInfoVendingappAppIdInfoGetResponseSuccess | appInfoVendingappAppIdInfoGetResponseError)

export const getAppInfoVendingappAppIdInfoGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/vendingapp/${appId}/info`
}

export const appInfoVendingappAppIdInfoGet = async (appId: string, options?: RequestInit): Promise<appInfoVendingappAppIdInfoGetResponse> => {
  
  const res = await fetch(getAppInfoVendingappAppIdInfoGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: appInfoVendingappAppIdInfoGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as appInfoVendingappAppIdInfoGetResponse
}



/**
 * Gets the verification status of the given app.
 * @summary Get Verification Status
 */
export type getVerificationStatusVerificationAppIdStatusGetResponse200 = {
  data: GetVerificationStatusVerificationAppIdStatusGet200
  status: 200
}

export type getVerificationStatusVerificationAppIdStatusGetResponse404 = {
  data: void
  status: 404
}

export type getVerificationStatusVerificationAppIdStatusGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getVerificationStatusVerificationAppIdStatusGetResponseSuccess = (getVerificationStatusVerificationAppIdStatusGetResponse200) & {
  headers: Headers;
};
export type getVerificationStatusVerificationAppIdStatusGetResponseError = (getVerificationStatusVerificationAppIdStatusGetResponse404 | getVerificationStatusVerificationAppIdStatusGetResponse422) & {
  headers: Headers;
};

export type getVerificationStatusVerificationAppIdStatusGetResponse = (getVerificationStatusVerificationAppIdStatusGetResponseSuccess | getVerificationStatusVerificationAppIdStatusGetResponseError)

export const getGetVerificationStatusVerificationAppIdStatusGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/verification/${appId}/status`
}

export const getVerificationStatusVerificationAppIdStatusGet = async (appId: string, options?: RequestInit): Promise<getVerificationStatusVerificationAppIdStatusGetResponse> => {
  
  const res = await fetch(getGetVerificationStatusVerificationAppIdStatusGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVerificationStatusVerificationAppIdStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVerificationStatusVerificationAppIdStatusGetResponse
}



/**
 * Gets the ways an app may be verified.
 * @summary Get Available Methods
 */
export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse200 = {
  data: AvailableMethods
  status: 200
}

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse401 = {
  data: void
  status: 401
}

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse404 = {
  data: void
  status: 404
}

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse500 = {
  data: void
  status: 500
}
    
export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseSuccess = (getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse200) & {
  headers: Headers;
};
export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseError = (getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse401 | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse404 | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse422 | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse500) & {
  headers: Headers;
};

export type getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse = (getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseSuccess | getAvailableMethodsVerificationAppIdAvailableMethodsGetResponseError)

export const getGetAvailableMethodsVerificationAppIdAvailableMethodsGetUrl = (appId: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/verification/${appId}/available-methods?${stringifiedParams}` : `https://flathub.org/api/v2/verification/${appId}/available-methods`
}

export const getAvailableMethodsVerificationAppIdAvailableMethodsGet = async (appId: string,
    params?: GetAvailableMethodsVerificationAppIdAvailableMethodsGetParams, options?: RequestInit): Promise<getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse> => {
  
  const res = await fetch(getGetAvailableMethodsVerificationAppIdAvailableMethodsGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAvailableMethodsVerificationAppIdAvailableMethodsGetResponse
}



/**
 * If the current account is eligible to verify the given account via SSO, and the app is not already verified by
someone else, marks the app as verified.
 * @summary Verify By Login Provider
 */
export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse200 = {
  data: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost200
  status: 200
}

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse401 = {
  data: void
  status: 401
}

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse403 = {
  data: void
  status: 403
}

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse404 = {
  data: void
  status: 404
}

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse422 = {
  data: void
  status: 422
}

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse500 = {
  data: void
  status: 500
}
    
export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseSuccess = (verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse200) & {
  headers: Headers;
};
export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseError = (verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse401 | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse403 | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse404 | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse422 | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse500) & {
  headers: Headers;
};

export type verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse = (verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseSuccess | verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponseError)

export const getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostUrl = (appId: string,
    params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/verification/${appId}/verify-by-login-provider?${stringifiedParams}` : `https://flathub.org/api/v2/verification/${appId}/verify-by-login-provider`
}

export const verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPost = async (appId: string,
    params?: VerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostParams, options?: RequestInit): Promise<verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse> => {
  
  const res = await fetch(getVerifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as verifyByLoginProviderVerificationAppIdVerifyByLoginProviderPostResponse
}



/**
 * Returns the URL to request access to the organization so we can verify the user's membership.
 * @summary Request Organization Access Github
 */
export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse200 = {
  data: LinkResponse
  status: 200
}

export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse500 = {
  data: void
  status: 500
}
    
export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseSuccess = (requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse200) & {
  headers: Headers;
};
export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseError = (requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse500) & {
  headers: Headers;
};

export type requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse = (requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseSuccess | requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponseError)

export const getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetUrl = () => {


  

  return `https://flathub.org/api/v2/verification/request-organization-access/github`
}

export const requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGet = async ( options?: RequestInit): Promise<requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse> => {
  
  const res = await fetch(getRequestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as requestOrganizationAccessGithubVerificationRequestOrganizationAccessGithubGetResponse
}



/**
 * Creates a token for the user to verify the app via website.
 * @summary Setup Website Verification
 */
export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse200 = {
  data: WebsiteVerificationToken
  status: 200
}

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse401 = {
  data: void
  status: 401
}

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse403 = {
  data: void
  status: 403
}

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse404 = {
  data: void
  status: 404
}

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse422 = {
  data: void
  status: 422
}

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse500 = {
  data: void
  status: 500
}
    
export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseSuccess = (setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse200) & {
  headers: Headers;
};
export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseError = (setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse401 | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse403 | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse404 | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse422 | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse500) & {
  headers: Headers;
};

export type setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse = (setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseSuccess | setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponseError)

export const getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostUrl = (appId: string,
    params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/verification/${appId}/setup-website-verification?${stringifiedParams}` : `https://flathub.org/api/v2/verification/${appId}/setup-website-verification`
}

export const setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPost = async (appId: string,
    params?: SetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostParams, options?: RequestInit): Promise<setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse> => {
  
  const res = await fetch(getSetupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setupWebsiteVerificationVerificationAppIdSetupWebsiteVerificationPostResponse
}



/**
 * Checks website verification, and if it succeeds, marks the app as verified for the current account.
 * @summary Confirm Website Verification
 */
export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse200 = {
  data: WebsiteVerificationResult
  status: 200
}

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse401 = {
  data: void
  status: 401
}

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse403 = {
  data: void
  status: 403
}

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse404 = {
  data: void
  status: 404
}

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse422 = {
  data: void
  status: 422
}

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse500 = {
  data: void
  status: 500
}
    
export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseSuccess = (confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse200) & {
  headers: Headers;
};
export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseError = (confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse401 | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse403 | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse404 | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse422 | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse500) & {
  headers: Headers;
};

export type confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse = (confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseSuccess | confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponseError)

export const getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostUrl = (appId: string,
    params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/verification/${appId}/confirm-website-verification?${stringifiedParams}` : `https://flathub.org/api/v2/verification/${appId}/confirm-website-verification`
}

export const confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPost = async (appId: string,
    params?: ConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostParams, options?: RequestInit): Promise<confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse> => {
  
  const res = await fetch(getConfirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as confirmWebsiteVerificationVerificationAppIdConfirmWebsiteVerificationPostResponse
}



/**
 * If the current account has verified the given app, mark it as no longer verified.
 * @summary Unverify
 */
export type unverifyVerificationAppIdUnverifyPostResponse204 = {
  data: void
  status: 204
}

export type unverifyVerificationAppIdUnverifyPostResponse401 = {
  data: void
  status: 401
}

export type unverifyVerificationAppIdUnverifyPostResponse403 = {
  data: void
  status: 403
}

export type unverifyVerificationAppIdUnverifyPostResponse404 = {
  data: void
  status: 404
}

export type unverifyVerificationAppIdUnverifyPostResponse422 = {
  data: void
  status: 422
}

export type unverifyVerificationAppIdUnverifyPostResponse500 = {
  data: void
  status: 500
}
    
export type unverifyVerificationAppIdUnverifyPostResponseSuccess = (unverifyVerificationAppIdUnverifyPostResponse204) & {
  headers: Headers;
};
export type unverifyVerificationAppIdUnverifyPostResponseError = (unverifyVerificationAppIdUnverifyPostResponse401 | unverifyVerificationAppIdUnverifyPostResponse403 | unverifyVerificationAppIdUnverifyPostResponse404 | unverifyVerificationAppIdUnverifyPostResponse422 | unverifyVerificationAppIdUnverifyPostResponse500) & {
  headers: Headers;
};

export type unverifyVerificationAppIdUnverifyPostResponse = (unverifyVerificationAppIdUnverifyPostResponseSuccess | unverifyVerificationAppIdUnverifyPostResponseError)

export const getUnverifyVerificationAppIdUnverifyPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/verification/${appId}/unverify`
}

export const unverifyVerificationAppIdUnverifyPost = async (appId: string, options?: RequestInit): Promise<unverifyVerificationAppIdUnverifyPostResponse> => {
  
  const res = await fetch(getUnverifyVerificationAppIdUnverifyPostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unverifyVerificationAppIdUnverifyPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unverifyVerificationAppIdUnverifyPostResponse
}



/**
 * @summary Switch To Direct Upload
 */
export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse204 = {
  data: void
  status: 204
}

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse401 = {
  data: void
  status: 401
}

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse403 = {
  data: void
  status: 403
}

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse404 = {
  data: void
  status: 404
}

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse422 = {
  data: void
  status: 422
}

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse500 = {
  data: void
  status: 500
}
    
export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseSuccess = (switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse204) & {
  headers: Headers;
};
export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseError = (switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse401 | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse403 | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse404 | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse422 | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse500) & {
  headers: Headers;
};

export type switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse = (switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseSuccess | switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponseError)

export const getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/verification/${appId}/switch_to_direct_upload`
}

export const switchToDirectUploadVerificationAppIdSwitchToDirectUploadPost = async (appId: string, options?: RequestInit): Promise<switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse> => {
  
  const res = await fetch(getSwitchToDirectUploadVerificationAppIdSwitchToDirectUploadPostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as switchToDirectUploadVerificationAppIdSwitchToDirectUploadPostResponse
}



/**
 * @summary Archive
 */
export type archiveVerificationAppIdArchivePostResponse204 = {
  data: void
  status: 204
}

export type archiveVerificationAppIdArchivePostResponse401 = {
  data: void
  status: 401
}

export type archiveVerificationAppIdArchivePostResponse403 = {
  data: void
  status: 403
}

export type archiveVerificationAppIdArchivePostResponse404 = {
  data: void
  status: 404
}

export type archiveVerificationAppIdArchivePostResponse422 = {
  data: void
  status: 422
}

export type archiveVerificationAppIdArchivePostResponse500 = {
  data: void
  status: 500
}
    
export type archiveVerificationAppIdArchivePostResponseSuccess = (archiveVerificationAppIdArchivePostResponse204) & {
  headers: Headers;
};
export type archiveVerificationAppIdArchivePostResponseError = (archiveVerificationAppIdArchivePostResponse401 | archiveVerificationAppIdArchivePostResponse403 | archiveVerificationAppIdArchivePostResponse404 | archiveVerificationAppIdArchivePostResponse422 | archiveVerificationAppIdArchivePostResponse500) & {
  headers: Headers;
};

export type archiveVerificationAppIdArchivePostResponse = (archiveVerificationAppIdArchivePostResponseSuccess | archiveVerificationAppIdArchivePostResponseError)

export const getArchiveVerificationAppIdArchivePostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/verification/${appId}/archive`
}

export const archiveVerificationAppIdArchivePost = async (appId: string,
    archiveRequest: ArchiveRequest, options?: RequestInit): Promise<archiveVerificationAppIdArchivePostResponse> => {
  
  const res = await fetch(getArchiveVerificationAppIdArchivePostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      archiveRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: archiveVerificationAppIdArchivePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as archiveVerificationAppIdArchivePostResponse
}



/**
 * This endpoint is used by the flathub-hooks scripts to get information about an app to insert into the appstream
file and commit metadata.
 * @summary Get Storefront Info
 */
export type getStorefrontInfoPurchasesStorefrontInfoGetResponse200 = {
  data: StorefrontInfo
  status: 200
}

export type getStorefrontInfoPurchasesStorefrontInfoGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getStorefrontInfoPurchasesStorefrontInfoGetResponseSuccess = (getStorefrontInfoPurchasesStorefrontInfoGetResponse200) & {
  headers: Headers;
};
export type getStorefrontInfoPurchasesStorefrontInfoGetResponseError = (getStorefrontInfoPurchasesStorefrontInfoGetResponse422) & {
  headers: Headers;
};

export type getStorefrontInfoPurchasesStorefrontInfoGetResponse = (getStorefrontInfoPurchasesStorefrontInfoGetResponseSuccess | getStorefrontInfoPurchasesStorefrontInfoGetResponseError)

export const getGetStorefrontInfoPurchasesStorefrontInfoGetUrl = (params: GetStorefrontInfoPurchasesStorefrontInfoGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/purchases/storefront-info?${stringifiedParams}` : `https://flathub.org/api/v2/purchases/storefront-info`
}

export const getStorefrontInfoPurchasesStorefrontInfoGet = async (params: GetStorefrontInfoPurchasesStorefrontInfoGetParams, options?: RequestInit): Promise<getStorefrontInfoPurchasesStorefrontInfoGetResponse> => {
  
  const res = await fetch(getGetStorefrontInfoPurchasesStorefrontInfoGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStorefrontInfoPurchasesStorefrontInfoGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStorefrontInfoPurchasesStorefrontInfoGetResponse
}



/**
 * Gets whether the app is Free Software based on the app ID and license, even if the app is not in the appstream
database yet. This is needed in flat-manager-hooks to run validations the first time an app is uploaded.
 * @summary Get Is Free Software
 */
export type getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse200 = {
  data: boolean
  status: 200
}

export type getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponseSuccess = (getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse200) & {
  headers: Headers;
};
export type getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponseError = (getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse422) & {
  headers: Headers;
};

export type getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse = (getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponseSuccess | getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponseError)

export const getGetIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetUrl = (params: GetIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/purchases/storefront-info/is-free-software?${stringifiedParams}` : `https://flathub.org/api/v2/purchases/storefront-info/is-free-software`
}

export const getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGet = async (params: GetIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetParams, options?: RequestInit): Promise<getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse> => {
  
  const res = await fetch(getGetIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getIsFreeSoftwarePurchasesStorefrontInfoIsFreeSoftwareGetResponse
}



/**
 * Generates an update token for a user account. This token allows the user to generate download tokens for apps they
already own, but does not grant permission to do anything else. By storing this token, flathub-authenticator is
able to update apps without user interaction.
 * @summary Get Update Token
 */
export type getUpdateTokenPurchasesGenerateUpdateTokenPostResponse200 = {
  data: GenerateUpdateTokenResponse
  status: 200
}

export type getUpdateTokenPurchasesGenerateUpdateTokenPostResponse401 = {
  data: void
  status: 401
}
    
export type getUpdateTokenPurchasesGenerateUpdateTokenPostResponseSuccess = (getUpdateTokenPurchasesGenerateUpdateTokenPostResponse200) & {
  headers: Headers;
};
export type getUpdateTokenPurchasesGenerateUpdateTokenPostResponseError = (getUpdateTokenPurchasesGenerateUpdateTokenPostResponse401) & {
  headers: Headers;
};

export type getUpdateTokenPurchasesGenerateUpdateTokenPostResponse = (getUpdateTokenPurchasesGenerateUpdateTokenPostResponseSuccess | getUpdateTokenPurchasesGenerateUpdateTokenPostResponseError)

export const getGetUpdateTokenPurchasesGenerateUpdateTokenPostUrl = () => {


  

  return `https://flathub.org/api/v2/purchases/generate-update-token`
}

export const getUpdateTokenPurchasesGenerateUpdateTokenPost = async ( options?: RequestInit): Promise<getUpdateTokenPurchasesGenerateUpdateTokenPostResponse> => {
  
  const res = await fetch(getGetUpdateTokenPurchasesGenerateUpdateTokenPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUpdateTokenPurchasesGenerateUpdateTokenPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUpdateTokenPurchasesGenerateUpdateTokenPostResponse
}



/**
 * Checks whether the logged in user is able to download all of the given app refs.

App IDs can be in the form of full refs, e.g. "app/org.gnome.Maps/x86_64/stable", or just the app ID, e.g.
"org.gnome.Maps".
 * @summary Check Purchases
 */
export type checkPurchasesPurchasesCheckPurchasesPostResponse200 = {
  data: CheckPurchasesResponseSuccess
  status: 200
}

export type checkPurchasesPurchasesCheckPurchasesPostResponse401 = {
  data: void
  status: 401
}

export type checkPurchasesPurchasesCheckPurchasesPostResponse403 = {
  data: void
  status: 403
}

export type checkPurchasesPurchasesCheckPurchasesPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type checkPurchasesPurchasesCheckPurchasesPostResponseSuccess = (checkPurchasesPurchasesCheckPurchasesPostResponse200) & {
  headers: Headers;
};
export type checkPurchasesPurchasesCheckPurchasesPostResponseError = (checkPurchasesPurchasesCheckPurchasesPostResponse401 | checkPurchasesPurchasesCheckPurchasesPostResponse403 | checkPurchasesPurchasesCheckPurchasesPostResponse422) & {
  headers: Headers;
};

export type checkPurchasesPurchasesCheckPurchasesPostResponse = (checkPurchasesPurchasesCheckPurchasesPostResponseSuccess | checkPurchasesPurchasesCheckPurchasesPostResponseError)

export const getCheckPurchasesPurchasesCheckPurchasesPostUrl = () => {


  

  return `https://flathub.org/api/v2/purchases/check-purchases`
}

export const checkPurchasesPurchasesCheckPurchasesPost = async (checkPurchasesPurchasesCheckPurchasesPostBody: string[], options?: RequestInit): Promise<checkPurchasesPurchasesCheckPurchasesPostResponse> => {
  
  const res = await fetch(getCheckPurchasesPurchasesCheckPurchasesPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      checkPurchasesPurchasesCheckPurchasesPostBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: checkPurchasesPurchasesCheckPurchasesPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as checkPurchasesPurchasesCheckPurchasesPostResponse
}



/**
 * Generates a download token for the given app IDs. App IDs should be in the form of full refs, e.g.
"app/org.gnome.Maps/x86_64/stable".
 * @summary Get Download Token
 */
export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse200 = {
  data: GetDownloadTokenResponse
  status: 200
}

export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse400 = {
  data: void
  status: 400
}

export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse401 = {
  data: void
  status: 401
}

export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse403 = {
  data: void
  status: 403
}

export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponseSuccess = (getDownloadTokenPurchasesGenerateDownloadTokenPostResponse200) & {
  headers: Headers;
};
export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponseError = (getDownloadTokenPurchasesGenerateDownloadTokenPostResponse400 | getDownloadTokenPurchasesGenerateDownloadTokenPostResponse401 | getDownloadTokenPurchasesGenerateDownloadTokenPostResponse403 | getDownloadTokenPurchasesGenerateDownloadTokenPostResponse422) & {
  headers: Headers;
};

export type getDownloadTokenPurchasesGenerateDownloadTokenPostResponse = (getDownloadTokenPurchasesGenerateDownloadTokenPostResponseSuccess | getDownloadTokenPurchasesGenerateDownloadTokenPostResponseError)

export const getGetDownloadTokenPurchasesGenerateDownloadTokenPostUrl = () => {


  

  return `https://flathub.org/api/v2/purchases/generate-download-token`
}

export const getDownloadTokenPurchasesGenerateDownloadTokenPost = async (bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost: BodyGetDownloadTokenPurchasesGenerateDownloadTokenPost, options?: RequestInit): Promise<getDownloadTokenPurchasesGenerateDownloadTokenPostResponse> => {
  
  const res = await fetch(getGetDownloadTokenPurchasesGenerateDownloadTokenPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bodyGetDownloadTokenPurchasesGenerateDownloadTokenPost,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDownloadTokenPurchasesGenerateDownloadTokenPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDownloadTokenPurchasesGenerateDownloadTokenPostResponse
}



/**
 * @summary Get Invite Status
 */
export type getInviteStatusInvitesAppIdGetResponse200 = {
  data: InviteStatus
  status: 200
}

export type getInviteStatusInvitesAppIdGetResponse401 = {
  data: void
  status: 401
}

export type getInviteStatusInvitesAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getInviteStatusInvitesAppIdGetResponse422 = {
  data: void
  status: 422
}

export type getInviteStatusInvitesAppIdGetResponse500 = {
  data: void
  status: 500
}
    
export type getInviteStatusInvitesAppIdGetResponseSuccess = (getInviteStatusInvitesAppIdGetResponse200) & {
  headers: Headers;
};
export type getInviteStatusInvitesAppIdGetResponseError = (getInviteStatusInvitesAppIdGetResponse401 | getInviteStatusInvitesAppIdGetResponse404 | getInviteStatusInvitesAppIdGetResponse422 | getInviteStatusInvitesAppIdGetResponse500) & {
  headers: Headers;
};

export type getInviteStatusInvitesAppIdGetResponse = (getInviteStatusInvitesAppIdGetResponseSuccess | getInviteStatusInvitesAppIdGetResponseError)

export const getGetInviteStatusInvitesAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/invites/${appId}`
}

export const getInviteStatusInvitesAppIdGet = async (appId: string, options?: RequestInit): Promise<getInviteStatusInvitesAppIdGetResponse> => {
  
  const res = await fetch(getGetInviteStatusInvitesAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getInviteStatusInvitesAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getInviteStatusInvitesAppIdGetResponse
}



/**
 * @summary Invite Developer
 */
export type inviteDeveloperInvitesAppIdInvitePostResponse204 = {
  data: void
  status: 204
}

export type inviteDeveloperInvitesAppIdInvitePostResponse401 = {
  data: void
  status: 401
}

export type inviteDeveloperInvitesAppIdInvitePostResponse403 = {
  data: void
  status: 403
}

export type inviteDeveloperInvitesAppIdInvitePostResponse404 = {
  data: void
  status: 404
}

export type inviteDeveloperInvitesAppIdInvitePostResponse409 = {
  data: void
  status: 409
}

export type inviteDeveloperInvitesAppIdInvitePostResponse422 = {
  data: void
  status: 422
}

export type inviteDeveloperInvitesAppIdInvitePostResponse500 = {
  data: void
  status: 500
}
    
export type inviteDeveloperInvitesAppIdInvitePostResponseSuccess = (inviteDeveloperInvitesAppIdInvitePostResponse204) & {
  headers: Headers;
};
export type inviteDeveloperInvitesAppIdInvitePostResponseError = (inviteDeveloperInvitesAppIdInvitePostResponse401 | inviteDeveloperInvitesAppIdInvitePostResponse403 | inviteDeveloperInvitesAppIdInvitePostResponse404 | inviteDeveloperInvitesAppIdInvitePostResponse409 | inviteDeveloperInvitesAppIdInvitePostResponse422 | inviteDeveloperInvitesAppIdInvitePostResponse500) & {
  headers: Headers;
};

export type inviteDeveloperInvitesAppIdInvitePostResponse = (inviteDeveloperInvitesAppIdInvitePostResponseSuccess | inviteDeveloperInvitesAppIdInvitePostResponseError)

export const getInviteDeveloperInvitesAppIdInvitePostUrl = (appId: string,
    params: InviteDeveloperInvitesAppIdInvitePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/invites/${appId}/invite?${stringifiedParams}` : `https://flathub.org/api/v2/invites/${appId}/invite`
}

export const inviteDeveloperInvitesAppIdInvitePost = async (appId: string,
    params: InviteDeveloperInvitesAppIdInvitePostParams, options?: RequestInit): Promise<inviteDeveloperInvitesAppIdInvitePostResponse> => {
  
  const res = await fetch(getInviteDeveloperInvitesAppIdInvitePostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: inviteDeveloperInvitesAppIdInvitePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as inviteDeveloperInvitesAppIdInvitePostResponse
}



/**
 * @summary Accept Invite
 */
export type acceptInviteInvitesAppIdAcceptPostResponse204 = {
  data: void
  status: 204
}

export type acceptInviteInvitesAppIdAcceptPostResponse401 = {
  data: void
  status: 401
}

export type acceptInviteInvitesAppIdAcceptPostResponse403 = {
  data: void
  status: 403
}

export type acceptInviteInvitesAppIdAcceptPostResponse404 = {
  data: void
  status: 404
}

export type acceptInviteInvitesAppIdAcceptPostResponse422 = {
  data: void
  status: 422
}

export type acceptInviteInvitesAppIdAcceptPostResponse500 = {
  data: void
  status: 500
}
    
export type acceptInviteInvitesAppIdAcceptPostResponseSuccess = (acceptInviteInvitesAppIdAcceptPostResponse204) & {
  headers: Headers;
};
export type acceptInviteInvitesAppIdAcceptPostResponseError = (acceptInviteInvitesAppIdAcceptPostResponse401 | acceptInviteInvitesAppIdAcceptPostResponse403 | acceptInviteInvitesAppIdAcceptPostResponse404 | acceptInviteInvitesAppIdAcceptPostResponse422 | acceptInviteInvitesAppIdAcceptPostResponse500) & {
  headers: Headers;
};

export type acceptInviteInvitesAppIdAcceptPostResponse = (acceptInviteInvitesAppIdAcceptPostResponseSuccess | acceptInviteInvitesAppIdAcceptPostResponseError)

export const getAcceptInviteInvitesAppIdAcceptPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/invites/${appId}/accept`
}

export const acceptInviteInvitesAppIdAcceptPost = async (appId: string, options?: RequestInit): Promise<acceptInviteInvitesAppIdAcceptPostResponse> => {
  
  const res = await fetch(getAcceptInviteInvitesAppIdAcceptPostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: acceptInviteInvitesAppIdAcceptPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as acceptInviteInvitesAppIdAcceptPostResponse
}



/**
 * @summary Decline Invite
 */
export type declineInviteInvitesAppIdDeclinePostResponse204 = {
  data: void
  status: 204
}

export type declineInviteInvitesAppIdDeclinePostResponse401 = {
  data: void
  status: 401
}

export type declineInviteInvitesAppIdDeclinePostResponse403 = {
  data: void
  status: 403
}

export type declineInviteInvitesAppIdDeclinePostResponse404 = {
  data: void
  status: 404
}

export type declineInviteInvitesAppIdDeclinePostResponse422 = {
  data: void
  status: 422
}

export type declineInviteInvitesAppIdDeclinePostResponse500 = {
  data: void
  status: 500
}
    
export type declineInviteInvitesAppIdDeclinePostResponseSuccess = (declineInviteInvitesAppIdDeclinePostResponse204) & {
  headers: Headers;
};
export type declineInviteInvitesAppIdDeclinePostResponseError = (declineInviteInvitesAppIdDeclinePostResponse401 | declineInviteInvitesAppIdDeclinePostResponse403 | declineInviteInvitesAppIdDeclinePostResponse404 | declineInviteInvitesAppIdDeclinePostResponse422 | declineInviteInvitesAppIdDeclinePostResponse500) & {
  headers: Headers;
};

export type declineInviteInvitesAppIdDeclinePostResponse = (declineInviteInvitesAppIdDeclinePostResponseSuccess | declineInviteInvitesAppIdDeclinePostResponseError)

export const getDeclineInviteInvitesAppIdDeclinePostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/invites/${appId}/decline`
}

export const declineInviteInvitesAppIdDeclinePost = async (appId: string, options?: RequestInit): Promise<declineInviteInvitesAppIdDeclinePostResponse> => {
  
  const res = await fetch(getDeclineInviteInvitesAppIdDeclinePostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: declineInviteInvitesAppIdDeclinePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as declineInviteInvitesAppIdDeclinePostResponse
}



/**
 * @summary Leave Team
 */
export type leaveTeamInvitesAppIdLeavePostResponse204 = {
  data: void
  status: 204
}

export type leaveTeamInvitesAppIdLeavePostResponse401 = {
  data: void
  status: 401
}

export type leaveTeamInvitesAppIdLeavePostResponse403 = {
  data: void
  status: 403
}

export type leaveTeamInvitesAppIdLeavePostResponse404 = {
  data: void
  status: 404
}

export type leaveTeamInvitesAppIdLeavePostResponse422 = {
  data: void
  status: 422
}

export type leaveTeamInvitesAppIdLeavePostResponse500 = {
  data: void
  status: 500
}
    
export type leaveTeamInvitesAppIdLeavePostResponseSuccess = (leaveTeamInvitesAppIdLeavePostResponse204) & {
  headers: Headers;
};
export type leaveTeamInvitesAppIdLeavePostResponseError = (leaveTeamInvitesAppIdLeavePostResponse401 | leaveTeamInvitesAppIdLeavePostResponse403 | leaveTeamInvitesAppIdLeavePostResponse404 | leaveTeamInvitesAppIdLeavePostResponse422 | leaveTeamInvitesAppIdLeavePostResponse500) & {
  headers: Headers;
};

export type leaveTeamInvitesAppIdLeavePostResponse = (leaveTeamInvitesAppIdLeavePostResponseSuccess | leaveTeamInvitesAppIdLeavePostResponseError)

export const getLeaveTeamInvitesAppIdLeavePostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/invites/${appId}/leave`
}

export const leaveTeamInvitesAppIdLeavePost = async (appId: string, options?: RequestInit): Promise<leaveTeamInvitesAppIdLeavePostResponse> => {
  
  const res = await fetch(getLeaveTeamInvitesAppIdLeavePostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: leaveTeamInvitesAppIdLeavePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as leaveTeamInvitesAppIdLeavePostResponse
}



/**
 * @summary Get App Developers
 */
export type getAppDevelopersInvitesAppIdDevelopersGetResponse200 = {
  data: AppRoutesInvitesDevelopersResponse
  status: 200
}

export type getAppDevelopersInvitesAppIdDevelopersGetResponse401 = {
  data: void
  status: 401
}

export type getAppDevelopersInvitesAppIdDevelopersGetResponse403 = {
  data: void
  status: 403
}

export type getAppDevelopersInvitesAppIdDevelopersGetResponse404 = {
  data: void
  status: 404
}

export type getAppDevelopersInvitesAppIdDevelopersGetResponse422 = {
  data: void
  status: 422
}

export type getAppDevelopersInvitesAppIdDevelopersGetResponse500 = {
  data: void
  status: 500
}
    
export type getAppDevelopersInvitesAppIdDevelopersGetResponseSuccess = (getAppDevelopersInvitesAppIdDevelopersGetResponse200) & {
  headers: Headers;
};
export type getAppDevelopersInvitesAppIdDevelopersGetResponseError = (getAppDevelopersInvitesAppIdDevelopersGetResponse401 | getAppDevelopersInvitesAppIdDevelopersGetResponse403 | getAppDevelopersInvitesAppIdDevelopersGetResponse404 | getAppDevelopersInvitesAppIdDevelopersGetResponse422 | getAppDevelopersInvitesAppIdDevelopersGetResponse500) & {
  headers: Headers;
};

export type getAppDevelopersInvitesAppIdDevelopersGetResponse = (getAppDevelopersInvitesAppIdDevelopersGetResponseSuccess | getAppDevelopersInvitesAppIdDevelopersGetResponseError)

export const getGetAppDevelopersInvitesAppIdDevelopersGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/invites/${appId}/developers`
}

export const getAppDevelopersInvitesAppIdDevelopersGet = async (appId: string, options?: RequestInit): Promise<getAppDevelopersInvitesAppIdDevelopersGetResponse> => {
  
  const res = await fetch(getGetAppDevelopersInvitesAppIdDevelopersGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppDevelopersInvitesAppIdDevelopersGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppDevelopersInvitesAppIdDevelopersGetResponse
}



/**
 * @summary Remove Developer
 */
export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse204 = {
  data: void
  status: 204
}

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse401 = {
  data: void
  status: 401
}

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse403 = {
  data: void
  status: 403
}

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse404 = {
  data: void
  status: 404
}

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse422 = {
  data: void
  status: 422
}

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse500 = {
  data: void
  status: 500
}
    
export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponseSuccess = (removeDeveloperInvitesAppIdRemoveDeveloperPostResponse204) & {
  headers: Headers;
};
export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponseError = (removeDeveloperInvitesAppIdRemoveDeveloperPostResponse401 | removeDeveloperInvitesAppIdRemoveDeveloperPostResponse403 | removeDeveloperInvitesAppIdRemoveDeveloperPostResponse404 | removeDeveloperInvitesAppIdRemoveDeveloperPostResponse422 | removeDeveloperInvitesAppIdRemoveDeveloperPostResponse500) & {
  headers: Headers;
};

export type removeDeveloperInvitesAppIdRemoveDeveloperPostResponse = (removeDeveloperInvitesAppIdRemoveDeveloperPostResponseSuccess | removeDeveloperInvitesAppIdRemoveDeveloperPostResponseError)

export const getRemoveDeveloperInvitesAppIdRemoveDeveloperPostUrl = (appId: string,
    params: RemoveDeveloperInvitesAppIdRemoveDeveloperPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/invites/${appId}/remove-developer?${stringifiedParams}` : `https://flathub.org/api/v2/invites/${appId}/remove-developer`
}

export const removeDeveloperInvitesAppIdRemoveDeveloperPost = async (appId: string,
    params: RemoveDeveloperInvitesAppIdRemoveDeveloperPostParams, options?: RequestInit): Promise<removeDeveloperInvitesAppIdRemoveDeveloperPostResponse> => {
  
  const res = await fetch(getRemoveDeveloperInvitesAppIdRemoveDeveloperPostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeDeveloperInvitesAppIdRemoveDeveloperPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeDeveloperInvitesAppIdRemoveDeveloperPostResponse
}



/**
 * @summary Revoke Invite
 */
export type revokeInviteInvitesAppIdRevokePostResponse204 = {
  data: void
  status: 204
}

export type revokeInviteInvitesAppIdRevokePostResponse401 = {
  data: void
  status: 401
}

export type revokeInviteInvitesAppIdRevokePostResponse403 = {
  data: void
  status: 403
}

export type revokeInviteInvitesAppIdRevokePostResponse404 = {
  data: void
  status: 404
}

export type revokeInviteInvitesAppIdRevokePostResponse422 = {
  data: void
  status: 422
}

export type revokeInviteInvitesAppIdRevokePostResponse500 = {
  data: void
  status: 500
}
    
export type revokeInviteInvitesAppIdRevokePostResponseSuccess = (revokeInviteInvitesAppIdRevokePostResponse204) & {
  headers: Headers;
};
export type revokeInviteInvitesAppIdRevokePostResponseError = (revokeInviteInvitesAppIdRevokePostResponse401 | revokeInviteInvitesAppIdRevokePostResponse403 | revokeInviteInvitesAppIdRevokePostResponse404 | revokeInviteInvitesAppIdRevokePostResponse422 | revokeInviteInvitesAppIdRevokePostResponse500) & {
  headers: Headers;
};

export type revokeInviteInvitesAppIdRevokePostResponse = (revokeInviteInvitesAppIdRevokePostResponseSuccess | revokeInviteInvitesAppIdRevokePostResponseError)

export const getRevokeInviteInvitesAppIdRevokePostUrl = (appId: string,
    params: RevokeInviteInvitesAppIdRevokePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/invites/${appId}/revoke?${stringifiedParams}` : `https://flathub.org/api/v2/invites/${appId}/revoke`
}

export const revokeInviteInvitesAppIdRevokePost = async (appId: string,
    params: RevokeInviteInvitesAppIdRevokePostParams, options?: RequestInit): Promise<revokeInviteInvitesAppIdRevokePostResponse> => {
  
  const res = await fetch(getRevokeInviteInvitesAppIdRevokePostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: revokeInviteInvitesAppIdRevokePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as revokeInviteInvitesAppIdRevokePostResponse
}



/**
 * @summary Get App Of The Day
 */
export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponse200 = {
  data: AppOfTheDay
  status: 200
}

export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponse404 = {
  data: void
  status: 404
}

export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponse422 = {
  data: void
  status: 422
}

export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponse500 = {
  data: void
  status: 500
}
    
export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponseSuccess = (getAppOfTheDayAppPicksAppOfTheDayDateGetResponse200) & {
  headers: Headers;
};
export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponseError = (getAppOfTheDayAppPicksAppOfTheDayDateGetResponse404 | getAppOfTheDayAppPicksAppOfTheDayDateGetResponse422 | getAppOfTheDayAppPicksAppOfTheDayDateGetResponse500) & {
  headers: Headers;
};

export type getAppOfTheDayAppPicksAppOfTheDayDateGetResponse = (getAppOfTheDayAppPicksAppOfTheDayDateGetResponseSuccess | getAppOfTheDayAppPicksAppOfTheDayDateGetResponseError)

export const getGetAppOfTheDayAppPicksAppOfTheDayDateGetUrl = (date: string,) => {


  

  return `https://flathub.org/api/v2/app-picks/app-of-the-day/${date}`
}

export const getAppOfTheDayAppPicksAppOfTheDayDateGet = async (date: string, options?: RequestInit): Promise<getAppOfTheDayAppPicksAppOfTheDayDateGetResponse> => {
  
  const res = await fetch(getGetAppOfTheDayAppPicksAppOfTheDayDateGetUrl(date),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppOfTheDayAppPicksAppOfTheDayDateGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppOfTheDayAppPicksAppOfTheDayDateGetResponse
}



/**
 * Returns apps of the week
 * @summary Get App Of The Week
 */
export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse200 = {
  data: AppsOfTheWeek
  status: 200
}

export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse404 = {
  data: void
  status: 404
}

export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse422 = {
  data: void
  status: 422
}

export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse500 = {
  data: void
  status: 500
}
    
export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponseSuccess = (getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse200) & {
  headers: Headers;
};
export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponseError = (getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse404 | getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse422 | getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse500) & {
  headers: Headers;
};

export type getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse = (getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponseSuccess | getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponseError)

export const getGetAppOfTheWeekAppPicksAppsOfTheWeekDateGetUrl = (date: string,) => {


  

  return `https://flathub.org/api/v2/app-picks/apps-of-the-week/${date}`
}

export const getAppOfTheWeekAppPicksAppsOfTheWeekDateGet = async (date: string, options?: RequestInit): Promise<getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse> => {
  
  const res = await fetch(getGetAppOfTheWeekAppPicksAppsOfTheWeekDateGetUrl(date),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppOfTheWeekAppPicksAppsOfTheWeekDateGetResponse
}



/**
 * Sets an app of the week
 * @summary Set App Of The Week
 */
export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse200 = {
  data: unknown
  status: 200
}

export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse401 = {
  data: void
  status: 401
}

export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse403 = {
  data: void
  status: 403
}

export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse422 = {
  data: void
  status: 422
}

export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse500 = {
  data: void
  status: 500
}
    
export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponseSuccess = (setAppOfTheWeekAppPicksAppOfTheWeekPostResponse200) & {
  headers: Headers;
};
export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponseError = (setAppOfTheWeekAppPicksAppOfTheWeekPostResponse401 | setAppOfTheWeekAppPicksAppOfTheWeekPostResponse403 | setAppOfTheWeekAppPicksAppOfTheWeekPostResponse422 | setAppOfTheWeekAppPicksAppOfTheWeekPostResponse500) & {
  headers: Headers;
};

export type setAppOfTheWeekAppPicksAppOfTheWeekPostResponse = (setAppOfTheWeekAppPicksAppOfTheWeekPostResponseSuccess | setAppOfTheWeekAppPicksAppOfTheWeekPostResponseError)

export const getSetAppOfTheWeekAppPicksAppOfTheWeekPostUrl = () => {


  

  return `https://flathub.org/api/v2/app-picks/app-of-the-week`
}

export const setAppOfTheWeekAppPicksAppOfTheWeekPost = async (upsertAppOfTheWeek: UpsertAppOfTheWeek, options?: RequestInit): Promise<setAppOfTheWeekAppPicksAppOfTheWeekPostResponse> => {
  
  const res = await fetch(getSetAppOfTheWeekAppPicksAppOfTheWeekPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      upsertAppOfTheWeek,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setAppOfTheWeekAppPicksAppOfTheWeekPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setAppOfTheWeekAppPicksAppOfTheWeekPostResponse
}



/**
 * Sets an app of the day
 * @summary Set App Of The Day
 */
export type setAppOfTheDayAppPicksAppOfTheDayPostResponse200 = {
  data: unknown
  status: 200
}

export type setAppOfTheDayAppPicksAppOfTheDayPostResponse401 = {
  data: void
  status: 401
}

export type setAppOfTheDayAppPicksAppOfTheDayPostResponse403 = {
  data: void
  status: 403
}

export type setAppOfTheDayAppPicksAppOfTheDayPostResponse422 = {
  data: void
  status: 422
}

export type setAppOfTheDayAppPicksAppOfTheDayPostResponse500 = {
  data: void
  status: 500
}
    
export type setAppOfTheDayAppPicksAppOfTheDayPostResponseSuccess = (setAppOfTheDayAppPicksAppOfTheDayPostResponse200) & {
  headers: Headers;
};
export type setAppOfTheDayAppPicksAppOfTheDayPostResponseError = (setAppOfTheDayAppPicksAppOfTheDayPostResponse401 | setAppOfTheDayAppPicksAppOfTheDayPostResponse403 | setAppOfTheDayAppPicksAppOfTheDayPostResponse422 | setAppOfTheDayAppPicksAppOfTheDayPostResponse500) & {
  headers: Headers;
};

export type setAppOfTheDayAppPicksAppOfTheDayPostResponse = (setAppOfTheDayAppPicksAppOfTheDayPostResponseSuccess | setAppOfTheDayAppPicksAppOfTheDayPostResponseError)

export const getSetAppOfTheDayAppPicksAppOfTheDayPostUrl = () => {


  

  return `https://flathub.org/api/v2/app-picks/app-of-the-day`
}

export const setAppOfTheDayAppPicksAppOfTheDayPost = async (appOfTheDay: AppOfTheDay, options?: RequestInit): Promise<setAppOfTheDayAppPicksAppOfTheDayPostResponse> => {
  
  const res = await fetch(getSetAppOfTheDayAppPicksAppOfTheDayPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      appOfTheDay,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setAppOfTheDayAppPicksAppOfTheDayPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setAppOfTheDayAppPicksAppOfTheDayPostResponse
}



/**
 * Get a list of all available main categories for filtering applications.
 * @summary Get Categories
 */
export type getCategoriesCollectionCategoryGetResponse200 = {
  data: string[]
  status: 200
}
    
export type getCategoriesCollectionCategoryGetResponseSuccess = (getCategoriesCollectionCategoryGetResponse200) & {
  headers: Headers;
};
;

export type getCategoriesCollectionCategoryGetResponse = (getCategoriesCollectionCategoryGetResponseSuccess)

export const getGetCategoriesCollectionCategoryGetUrl = () => {


  

  return `https://flathub.org/api/v2/collection/category`
}

export const getCategoriesCollectionCategoryGet = async ( options?: RequestInit): Promise<getCategoriesCollectionCategoryGetResponse> => {
  
  const res = await fetch(getGetCategoriesCollectionCategoryGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCategoriesCollectionCategoryGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCategoriesCollectionCategoryGetResponse
}



/**
 * Get applications in a specific main category.

Supports pagination, subcategory exclusion, and custom sorting.
 * @summary Get Category
 */
export type getCategoryCollectionCategoryCategoryGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getCategoryCollectionCategoryCategoryGetResponse400 = {
  data: void
  status: 400
}

export type getCategoryCollectionCategoryCategoryGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getCategoryCollectionCategoryCategoryGetResponseSuccess = (getCategoryCollectionCategoryCategoryGetResponse200) & {
  headers: Headers;
};
export type getCategoryCollectionCategoryCategoryGetResponseError = (getCategoryCollectionCategoryCategoryGetResponse400 | getCategoryCollectionCategoryCategoryGetResponse422) & {
  headers: Headers;
};

export type getCategoryCollectionCategoryCategoryGetResponse = (getCategoryCollectionCategoryCategoryGetResponseSuccess | getCategoryCollectionCategoryCategoryGetResponseError)

export const getGetCategoryCollectionCategoryCategoryGetUrl = (category: MainCategory,
    params?: GetCategoryCollectionCategoryCategoryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["exclude_subcategories"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/category/${category}?${stringifiedParams}` : `https://flathub.org/api/v2/collection/category/${category}`
}

export const getCategoryCollectionCategoryCategoryGet = async (category: MainCategory,
    params?: GetCategoryCollectionCategoryCategoryGetParams, options?: RequestInit): Promise<getCategoryCollectionCategoryCategoryGetResponse> => {
  
  const res = await fetch(getGetCategoryCollectionCategoryCategoryGetUrl(category,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCategoryCollectionCategoryCategoryGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCategoryCollectionCategoryCategoryGetResponse
}



/**
 * Get applications in specific subcategories within a main category.

Filters by one or more subcategories (e.g., "ActionGame", "ArcadeGame")
with optional exclusions and sorting.
 * @summary Get Subcategory
 */
export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse400 = {
  data: void
  status: 400
}

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseSuccess = (getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse200) & {
  headers: Headers;
};
export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseError = (getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse400 | getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse422) & {
  headers: Headers;
};

export type getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse = (getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseSuccess | getSubcategoryCollectionCategoryCategorySubcategoriesGetResponseError)

export const getGetSubcategoryCollectionCategoryCategorySubcategoriesGetUrl = (category: MainCategory,
    params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["subcategory","exclude_subcategories"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/category/${category}/subcategories?${stringifiedParams}` : `https://flathub.org/api/v2/collection/category/${category}/subcategories`
}

export const getSubcategoryCollectionCategoryCategorySubcategoriesGet = async (category: MainCategory,
    params: GetSubcategoryCollectionCategoryCategorySubcategoriesGetParams, options?: RequestInit): Promise<getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse> => {
  
  const res = await fetch(getGetSubcategoryCollectionCategoryCategorySubcategoriesGetUrl(category,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSubcategoryCollectionCategoryCategorySubcategoriesGetResponse
}



/**
 * Search for applications by keyword.

Returns apps that have the specified keyword in their metadata.
 * @summary Get Keyword
 */
export type getKeywordCollectionKeywordGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getKeywordCollectionKeywordGetResponse400 = {
  data: void
  status: 400
}

export type getKeywordCollectionKeywordGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getKeywordCollectionKeywordGetResponseSuccess = (getKeywordCollectionKeywordGetResponse200) & {
  headers: Headers;
};
export type getKeywordCollectionKeywordGetResponseError = (getKeywordCollectionKeywordGetResponse400 | getKeywordCollectionKeywordGetResponse422) & {
  headers: Headers;
};

export type getKeywordCollectionKeywordGetResponse = (getKeywordCollectionKeywordGetResponseSuccess | getKeywordCollectionKeywordGetResponseError)

export const getGetKeywordCollectionKeywordGetUrl = (params: GetKeywordCollectionKeywordGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/keyword?${stringifiedParams}` : `https://flathub.org/api/v2/collection/keyword`
}

export const getKeywordCollectionKeywordGet = async (params: GetKeywordCollectionKeywordGetParams, options?: RequestInit): Promise<getKeywordCollectionKeywordGetResponse> => {
  
  const res = await fetch(getGetKeywordCollectionKeywordGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getKeywordCollectionKeywordGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getKeywordCollectionKeywordGetResponse
}



/**
 * Get a paginated list of all developers/publishers on Flathub.

Returns developer names that can be used to filter applications.
 * @summary Get Developers
 */
export type getDevelopersCollectionDeveloperGetResponse200 = {
  data: AppSearchDevelopersResponse
  status: 200
}

export type getDevelopersCollectionDeveloperGetResponse400 = {
  data: void
  status: 400
}

export type getDevelopersCollectionDeveloperGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getDevelopersCollectionDeveloperGetResponseSuccess = (getDevelopersCollectionDeveloperGetResponse200) & {
  headers: Headers;
};
export type getDevelopersCollectionDeveloperGetResponseError = (getDevelopersCollectionDeveloperGetResponse400 | getDevelopersCollectionDeveloperGetResponse422) & {
  headers: Headers;
};

export type getDevelopersCollectionDeveloperGetResponse = (getDevelopersCollectionDeveloperGetResponseSuccess | getDevelopersCollectionDeveloperGetResponseError)

export const getGetDevelopersCollectionDeveloperGetUrl = (params?: GetDevelopersCollectionDeveloperGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/developer?${stringifiedParams}` : `https://flathub.org/api/v2/collection/developer`
}

export const getDevelopersCollectionDeveloperGet = async (params?: GetDevelopersCollectionDeveloperGetParams, options?: RequestInit): Promise<getDevelopersCollectionDeveloperGetResponse> => {
  
  const res = await fetch(getGetDevelopersCollectionDeveloperGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDevelopersCollectionDeveloperGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDevelopersCollectionDeveloperGetResponse
}



/**
 * Get all applications published by a specific developer.

The developer parameter should match the developer_name field from appstream data.
 * @summary Get Developer
 */
export type getDeveloperCollectionDeveloperDeveloperGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getDeveloperCollectionDeveloperDeveloperGetResponse400 = {
  data: void
  status: 400
}

export type getDeveloperCollectionDeveloperDeveloperGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getDeveloperCollectionDeveloperDeveloperGetResponseSuccess = (getDeveloperCollectionDeveloperDeveloperGetResponse200) & {
  headers: Headers;
};
export type getDeveloperCollectionDeveloperDeveloperGetResponseError = (getDeveloperCollectionDeveloperDeveloperGetResponse400 | getDeveloperCollectionDeveloperDeveloperGetResponse422) & {
  headers: Headers;
};

export type getDeveloperCollectionDeveloperDeveloperGetResponse = (getDeveloperCollectionDeveloperDeveloperGetResponseSuccess | getDeveloperCollectionDeveloperDeveloperGetResponseError)

export const getGetDeveloperCollectionDeveloperDeveloperGetUrl = (developer: string,
    params?: GetDeveloperCollectionDeveloperDeveloperGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/developer/${developer}?${stringifiedParams}` : `https://flathub.org/api/v2/collection/developer/${developer}`
}

export const getDeveloperCollectionDeveloperDeveloperGet = async (developer: string,
    params?: GetDeveloperCollectionDeveloperDeveloperGetParams, options?: RequestInit): Promise<getDeveloperCollectionDeveloperDeveloperGetResponse> => {
  
  const res = await fetch(getGetDeveloperCollectionDeveloperDeveloperGetUrl(developer,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getDeveloperCollectionDeveloperDeveloperGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getDeveloperCollectionDeveloperDeveloperGetResponse
}



/**
 * Get applications that have been recently updated.

Sorted by the most recent release timestamp.
 * @summary Get Recently Updated
 */
export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse400 = {
  data: void
  status: 400
}

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseSuccess = (getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse200) & {
  headers: Headers;
};
export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseError = (getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse400 | getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse422) & {
  headers: Headers;
};

export type getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse = (getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseSuccess | getRecentlyUpdatedCollectionRecentlyUpdatedGetResponseError)

export const getGetRecentlyUpdatedCollectionRecentlyUpdatedGetUrl = (params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/recently-updated?${stringifiedParams}` : `https://flathub.org/api/v2/collection/recently-updated`
}

export const getRecentlyUpdatedCollectionRecentlyUpdatedGet = async (params?: GetRecentlyUpdatedCollectionRecentlyUpdatedGetParams, options?: RequestInit): Promise<getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse> => {
  
  const res = await fetch(getGetRecentlyUpdatedCollectionRecentlyUpdatedGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyUpdatedCollectionRecentlyUpdatedGetResponse
}



/**
 * Get applications that have been recently added to Flathub.

Sorted by the date the app was first published.
 * @summary Get Recently Added
 */
export type getRecentlyAddedCollectionRecentlyAddedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getRecentlyAddedCollectionRecentlyAddedGetResponse400 = {
  data: void
  status: 400
}

export type getRecentlyAddedCollectionRecentlyAddedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getRecentlyAddedCollectionRecentlyAddedGetResponseSuccess = (getRecentlyAddedCollectionRecentlyAddedGetResponse200) & {
  headers: Headers;
};
export type getRecentlyAddedCollectionRecentlyAddedGetResponseError = (getRecentlyAddedCollectionRecentlyAddedGetResponse400 | getRecentlyAddedCollectionRecentlyAddedGetResponse422) & {
  headers: Headers;
};

export type getRecentlyAddedCollectionRecentlyAddedGetResponse = (getRecentlyAddedCollectionRecentlyAddedGetResponseSuccess | getRecentlyAddedCollectionRecentlyAddedGetResponseError)

export const getGetRecentlyAddedCollectionRecentlyAddedGetUrl = (params?: GetRecentlyAddedCollectionRecentlyAddedGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/recently-added?${stringifiedParams}` : `https://flathub.org/api/v2/collection/recently-added`
}

export const getRecentlyAddedCollectionRecentlyAddedGet = async (params?: GetRecentlyAddedCollectionRecentlyAddedGetParams, options?: RequestInit): Promise<getRecentlyAddedCollectionRecentlyAddedGetResponse> => {
  
  const res = await fetch(getGetRecentlyAddedCollectionRecentlyAddedGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyAddedCollectionRecentlyAddedGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyAddedCollectionRecentlyAddedGetResponse
}



/**
 * Get applications that have been verified by Flathub.

Verified apps have proven ownership/authenticity through one of the
verification methods (website, GitHub org, GitLab group, etc.).
 * @summary Get Verified
 */
export type getVerifiedCollectionVerifiedGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getVerifiedCollectionVerifiedGetResponse400 = {
  data: void
  status: 400
}

export type getVerifiedCollectionVerifiedGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getVerifiedCollectionVerifiedGetResponseSuccess = (getVerifiedCollectionVerifiedGetResponse200) & {
  headers: Headers;
};
export type getVerifiedCollectionVerifiedGetResponseError = (getVerifiedCollectionVerifiedGetResponse400 | getVerifiedCollectionVerifiedGetResponse422) & {
  headers: Headers;
};

export type getVerifiedCollectionVerifiedGetResponse = (getVerifiedCollectionVerifiedGetResponseSuccess | getVerifiedCollectionVerifiedGetResponseError)

export const getGetVerifiedCollectionVerifiedGetUrl = (params?: GetVerifiedCollectionVerifiedGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/verified?${stringifiedParams}` : `https://flathub.org/api/v2/collection/verified`
}

export const getVerifiedCollectionVerifiedGet = async (params?: GetVerifiedCollectionVerifiedGetParams, options?: RequestInit): Promise<getVerifiedCollectionVerifiedGetResponse> => {
  
  const res = await fetch(getGetVerifiedCollectionVerifiedGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVerifiedCollectionVerifiedGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVerifiedCollectionVerifiedGetResponse
}



/**
 * Get applications that are mobile-friendly.

These apps are designed to work well on mobile devices and
have the isMobileFriendly flag set in their metadata.
 * @summary Get Mobile
 */
export type getMobileCollectionMobileGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getMobileCollectionMobileGetResponse400 = {
  data: void
  status: 400
}

export type getMobileCollectionMobileGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getMobileCollectionMobileGetResponseSuccess = (getMobileCollectionMobileGetResponse200) & {
  headers: Headers;
};
export type getMobileCollectionMobileGetResponseError = (getMobileCollectionMobileGetResponse400 | getMobileCollectionMobileGetResponse422) & {
  headers: Headers;
};

export type getMobileCollectionMobileGetResponse = (getMobileCollectionMobileGetResponseSuccess | getMobileCollectionMobileGetResponseError)

export const getGetMobileCollectionMobileGetUrl = (params?: GetMobileCollectionMobileGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/mobile?${stringifiedParams}` : `https://flathub.org/api/v2/collection/mobile`
}

export const getMobileCollectionMobileGet = async (params?: GetMobileCollectionMobileGetParams, options?: RequestInit): Promise<getMobileCollectionMobileGetResponse> => {
  
  const res = await fetch(getGetMobileCollectionMobileGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getMobileCollectionMobileGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getMobileCollectionMobileGetResponse
}



/**
 * Get the most popular applications based on installs in the last month.

Sorted by the number of installations in the previous 30 days.
 * @summary Get Popular Last Month
 */
export type getPopularLastMonthCollectionPopularGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getPopularLastMonthCollectionPopularGetResponse400 = {
  data: void
  status: 400
}

export type getPopularLastMonthCollectionPopularGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getPopularLastMonthCollectionPopularGetResponseSuccess = (getPopularLastMonthCollectionPopularGetResponse200) & {
  headers: Headers;
};
export type getPopularLastMonthCollectionPopularGetResponseError = (getPopularLastMonthCollectionPopularGetResponse400 | getPopularLastMonthCollectionPopularGetResponse422) & {
  headers: Headers;
};

export type getPopularLastMonthCollectionPopularGetResponse = (getPopularLastMonthCollectionPopularGetResponseSuccess | getPopularLastMonthCollectionPopularGetResponseError)

export const getGetPopularLastMonthCollectionPopularGetUrl = (params?: GetPopularLastMonthCollectionPopularGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/popular?${stringifiedParams}` : `https://flathub.org/api/v2/collection/popular`
}

export const getPopularLastMonthCollectionPopularGet = async (params?: GetPopularLastMonthCollectionPopularGetParams, options?: RequestInit): Promise<getPopularLastMonthCollectionPopularGetResponse> => {
  
  const res = await fetch(getGetPopularLastMonthCollectionPopularGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPopularLastMonthCollectionPopularGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPopularLastMonthCollectionPopularGetResponse
}



/**
 * Get trending applications based on recent growth in installs.

Uses a trending score calculated from install growth over the last two weeks,
highlighting apps that are gaining popularity.
 * @summary Get Trending Last Two Weeks
 */
export type getTrendingLastTwoWeeksCollectionTrendingGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse400 = {
  data: void
  status: 400
}

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getTrendingLastTwoWeeksCollectionTrendingGetResponseSuccess = (getTrendingLastTwoWeeksCollectionTrendingGetResponse200) & {
  headers: Headers;
};
export type getTrendingLastTwoWeeksCollectionTrendingGetResponseError = (getTrendingLastTwoWeeksCollectionTrendingGetResponse400 | getTrendingLastTwoWeeksCollectionTrendingGetResponse422) & {
  headers: Headers;
};

export type getTrendingLastTwoWeeksCollectionTrendingGetResponse = (getTrendingLastTwoWeeksCollectionTrendingGetResponseSuccess | getTrendingLastTwoWeeksCollectionTrendingGetResponseError)

export const getGetTrendingLastTwoWeeksCollectionTrendingGetUrl = (params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/trending?${stringifiedParams}` : `https://flathub.org/api/v2/collection/trending`
}

export const getTrendingLastTwoWeeksCollectionTrendingGet = async (params?: GetTrendingLastTwoWeeksCollectionTrendingGetParams, options?: RequestInit): Promise<getTrendingLastTwoWeeksCollectionTrendingGetResponse> => {
  
  const res = await fetch(getGetTrendingLastTwoWeeksCollectionTrendingGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTrendingLastTwoWeeksCollectionTrendingGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTrendingLastTwoWeeksCollectionTrendingGetResponse
}



/**
 * Get applications sorted by the number of times they have been favorited.

Returns apps ordered by their favorites count in descending order,
showing the most popular apps among users.
 * @summary Get Most Favorited
 */
export type getMostFavoritedCollectionFavoritesGetResponse200 = {
  data: MeilisearchResponseAppsIndex
  status: 200
}

export type getMostFavoritedCollectionFavoritesGetResponse400 = {
  data: void
  status: 400
}

export type getMostFavoritedCollectionFavoritesGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getMostFavoritedCollectionFavoritesGetResponseSuccess = (getMostFavoritedCollectionFavoritesGetResponse200) & {
  headers: Headers;
};
export type getMostFavoritedCollectionFavoritesGetResponseError = (getMostFavoritedCollectionFavoritesGetResponse400 | getMostFavoritedCollectionFavoritesGetResponse422) & {
  headers: Headers;
};

export type getMostFavoritedCollectionFavoritesGetResponse = (getMostFavoritedCollectionFavoritesGetResponseSuccess | getMostFavoritedCollectionFavoritesGetResponseError)

export const getGetMostFavoritedCollectionFavoritesGetUrl = (params?: GetMostFavoritedCollectionFavoritesGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/collection/favorites?${stringifiedParams}` : `https://flathub.org/api/v2/collection/favorites`
}

export const getMostFavoritedCollectionFavoritesGet = async (params?: GetMostFavoritedCollectionFavoritesGetParams, options?: RequestInit): Promise<getMostFavoritedCollectionFavoritesGetResponse> => {
  
  const res = await fetch(getGetMostFavoritedCollectionFavoritesGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getMostFavoritedCollectionFavoritesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getMostFavoritedCollectionFavoritesGetResponse
}



/**
 * @summary Get Recently Updated
 */
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse200 = {
  data: unknown
  status: 200
}

export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse500 = {
  data: void
  status: 500
}
    
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponseSuccess = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse200) & {
  headers: Headers;
};
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponseError = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse500) & {
  headers: Headers;
};

export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponseSuccess | getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponseError)

export const getGetRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/recently-updated/25`
}

export const getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25Get = async ( options?: RequestInit): Promise<getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse> => {
  
  const res = await fetch(getGetRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyUpdatedCompatAppsCollectionRecentlyUpdated25GetResponse
}



/**
 * @summary Get Recently Updated
 */
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse200 = {
  data: unknown
  status: 200
}

export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse500 = {
  data: void
  status: 500
}
    
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponseSuccess = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse200) & {
  headers: Headers;
};
export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponseError = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse500) & {
  headers: Headers;
};

export type getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse = (getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponseSuccess | getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponseError)

export const getGetRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/recently-updated`
}

export const getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGet = async ( options?: RequestInit): Promise<getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse> => {
  
  const res = await fetch(getGetRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyUpdatedCompatAppsCollectionRecentlyUpdatedGetResponse
}



/**
 * @summary Get Recently Added
 */
export type getRecentlyAddedCompatAppsCollectionNew25GetResponse200 = {
  data: unknown
  status: 200
}

export type getRecentlyAddedCompatAppsCollectionNew25GetResponse500 = {
  data: void
  status: 500
}
    
export type getRecentlyAddedCompatAppsCollectionNew25GetResponseSuccess = (getRecentlyAddedCompatAppsCollectionNew25GetResponse200) & {
  headers: Headers;
};
export type getRecentlyAddedCompatAppsCollectionNew25GetResponseError = (getRecentlyAddedCompatAppsCollectionNew25GetResponse500) & {
  headers: Headers;
};

export type getRecentlyAddedCompatAppsCollectionNew25GetResponse = (getRecentlyAddedCompatAppsCollectionNew25GetResponseSuccess | getRecentlyAddedCompatAppsCollectionNew25GetResponseError)

export const getGetRecentlyAddedCompatAppsCollectionNew25GetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/new/25`
}

export const getRecentlyAddedCompatAppsCollectionNew25Get = async ( options?: RequestInit): Promise<getRecentlyAddedCompatAppsCollectionNew25GetResponse> => {
  
  const res = await fetch(getGetRecentlyAddedCompatAppsCollectionNew25GetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyAddedCompatAppsCollectionNew25GetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyAddedCompatAppsCollectionNew25GetResponse
}



/**
 * @summary Get Recently Added
 */
export type getRecentlyAddedCompatAppsCollectionNewGetResponse200 = {
  data: unknown
  status: 200
}

export type getRecentlyAddedCompatAppsCollectionNewGetResponse500 = {
  data: void
  status: 500
}
    
export type getRecentlyAddedCompatAppsCollectionNewGetResponseSuccess = (getRecentlyAddedCompatAppsCollectionNewGetResponse200) & {
  headers: Headers;
};
export type getRecentlyAddedCompatAppsCollectionNewGetResponseError = (getRecentlyAddedCompatAppsCollectionNewGetResponse500) & {
  headers: Headers;
};

export type getRecentlyAddedCompatAppsCollectionNewGetResponse = (getRecentlyAddedCompatAppsCollectionNewGetResponseSuccess | getRecentlyAddedCompatAppsCollectionNewGetResponseError)

export const getGetRecentlyAddedCompatAppsCollectionNewGetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/new`
}

export const getRecentlyAddedCompatAppsCollectionNewGet = async ( options?: RequestInit): Promise<getRecentlyAddedCompatAppsCollectionNewGetResponse> => {
  
  const res = await fetch(getGetRecentlyAddedCompatAppsCollectionNewGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyAddedCompatAppsCollectionNewGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyAddedCompatAppsCollectionNewGetResponse
}



/**
 * @summary Get Popular Apps
 */
export type getPopularAppsCompatAppsCollectionPopular50GetResponse200 = {
  data: unknown
  status: 200
}

export type getPopularAppsCompatAppsCollectionPopular50GetResponse500 = {
  data: void
  status: 500
}
    
export type getPopularAppsCompatAppsCollectionPopular50GetResponseSuccess = (getPopularAppsCompatAppsCollectionPopular50GetResponse200) & {
  headers: Headers;
};
export type getPopularAppsCompatAppsCollectionPopular50GetResponseError = (getPopularAppsCompatAppsCollectionPopular50GetResponse500) & {
  headers: Headers;
};

export type getPopularAppsCompatAppsCollectionPopular50GetResponse = (getPopularAppsCompatAppsCollectionPopular50GetResponseSuccess | getPopularAppsCompatAppsCollectionPopular50GetResponseError)

export const getGetPopularAppsCompatAppsCollectionPopular50GetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/popular/50`
}

export const getPopularAppsCompatAppsCollectionPopular50Get = async ( options?: RequestInit): Promise<getPopularAppsCompatAppsCollectionPopular50GetResponse> => {
  
  const res = await fetch(getGetPopularAppsCompatAppsCollectionPopular50GetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPopularAppsCompatAppsCollectionPopular50GetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPopularAppsCompatAppsCollectionPopular50GetResponse
}



/**
 * @summary Get Popular Apps
 */
export type getPopularAppsCompatAppsCollectionPopularGetResponse200 = {
  data: unknown
  status: 200
}

export type getPopularAppsCompatAppsCollectionPopularGetResponse500 = {
  data: void
  status: 500
}
    
export type getPopularAppsCompatAppsCollectionPopularGetResponseSuccess = (getPopularAppsCompatAppsCollectionPopularGetResponse200) & {
  headers: Headers;
};
export type getPopularAppsCompatAppsCollectionPopularGetResponseError = (getPopularAppsCompatAppsCollectionPopularGetResponse500) & {
  headers: Headers;
};

export type getPopularAppsCompatAppsCollectionPopularGetResponse = (getPopularAppsCompatAppsCollectionPopularGetResponseSuccess | getPopularAppsCompatAppsCollectionPopularGetResponseError)

export const getGetPopularAppsCompatAppsCollectionPopularGetUrl = () => {


  

  return `https://flathub.org/api/v2/compat/apps/collection/popular`
}

export const getPopularAppsCompatAppsCollectionPopularGet = async ( options?: RequestInit): Promise<getPopularAppsCompatAppsCollectionPopularGetResponse> => {
  
  const res = await fetch(getGetPopularAppsCompatAppsCollectionPopularGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPopularAppsCompatAppsCollectionPopularGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPopularAppsCompatAppsCollectionPopularGetResponse
}



/**
 * @summary Get Search
 */
export type getSearchCompatAppsSearchQueryGetResponse200 = {
  data: unknown
  status: 200
}

export type getSearchCompatAppsSearchQueryGetResponse422 = {
  data: void
  status: 422
}

export type getSearchCompatAppsSearchQueryGetResponse500 = {
  data: void
  status: 500
}
    
export type getSearchCompatAppsSearchQueryGetResponseSuccess = (getSearchCompatAppsSearchQueryGetResponse200) & {
  headers: Headers;
};
export type getSearchCompatAppsSearchQueryGetResponseError = (getSearchCompatAppsSearchQueryGetResponse422 | getSearchCompatAppsSearchQueryGetResponse500) & {
  headers: Headers;
};

export type getSearchCompatAppsSearchQueryGetResponse = (getSearchCompatAppsSearchQueryGetResponseSuccess | getSearchCompatAppsSearchQueryGetResponseError)

export const getGetSearchCompatAppsSearchQueryGetUrl = (query: string,
    params?: GetSearchCompatAppsSearchQueryGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/compat/apps/search/${query}?${stringifiedParams}` : `https://flathub.org/api/v2/compat/apps/search/${query}`
}

export const getSearchCompatAppsSearchQueryGet = async (query: string,
    params?: GetSearchCompatAppsSearchQueryGetParams, options?: RequestInit): Promise<getSearchCompatAppsSearchQueryGetResponse> => {
  
  const res = await fetch(getGetSearchCompatAppsSearchQueryGetUrl(query,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSearchCompatAppsSearchQueryGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSearchCompatAppsSearchQueryGetResponse
}



/**
 * @summary Get Single App
 */
export type getSingleAppCompatAppsAppIdGetResponse200 = {
  data: unknown
  status: 200
}

export type getSingleAppCompatAppsAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getSingleAppCompatAppsAppIdGetResponse422 = {
  data: void
  status: 422
}

export type getSingleAppCompatAppsAppIdGetResponse500 = {
  data: void
  status: 500
}
    
export type getSingleAppCompatAppsAppIdGetResponseSuccess = (getSingleAppCompatAppsAppIdGetResponse200) & {
  headers: Headers;
};
export type getSingleAppCompatAppsAppIdGetResponseError = (getSingleAppCompatAppsAppIdGetResponse404 | getSingleAppCompatAppsAppIdGetResponse422 | getSingleAppCompatAppsAppIdGetResponse500) & {
  headers: Headers;
};

export type getSingleAppCompatAppsAppIdGetResponse = (getSingleAppCompatAppsAppIdGetResponseSuccess | getSingleAppCompatAppsAppIdGetResponseError)

export const getGetSingleAppCompatAppsAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/compat/apps/${appId}`
}

export const getSingleAppCompatAppsAppIdGet = async (appId: string, options?: RequestInit): Promise<getSingleAppCompatAppsAppIdGetResponse> => {
  
  const res = await fetch(getGetSingleAppCompatAppsAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSingleAppCompatAppsAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSingleAppCompatAppsAppIdGetResponse
}



/**
 * @summary Get Recently Updated Apps Feed
 */
export type getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse200 = {
  data: unknown
  status: 200
}
    
export type getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponseSuccess = (getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse200) & {
  headers: Headers;
};
;

export type getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse = (getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponseSuccess)

export const getGetRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetUrl = () => {


  

  return `https://flathub.org/api/v2/feed/recently-updated`
}

export const getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGet = async ( options?: RequestInit): Promise<getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse> => {
  
  const res = await fetch(getGetRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getRecentlyUpdatedAppsFeedFeedRecentlyUpdatedGetResponse
}



/**
 * @summary Get New Apps Feed
 */
export type getNewAppsFeedFeedNewGetResponse200 = {
  data: unknown
  status: 200
}
    
export type getNewAppsFeedFeedNewGetResponseSuccess = (getNewAppsFeedFeedNewGetResponse200) & {
  headers: Headers;
};
;

export type getNewAppsFeedFeedNewGetResponse = (getNewAppsFeedFeedNewGetResponseSuccess)

export const getGetNewAppsFeedFeedNewGetUrl = () => {


  

  return `https://flathub.org/api/v2/feed/new`
}

export const getNewAppsFeedFeedNewGet = async ( options?: RequestInit): Promise<getNewAppsFeedFeedNewGetResponse> => {
  
  const res = await fetch(getGetNewAppsFeedFeedNewGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getNewAppsFeedFeedNewGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getNewAppsFeedFeedNewGetResponse
}



/**
 * @summary Get Quality Moderation Status
 */
export type getQualityModerationStatusQualityModerationStatusGetResponse200 = {
  data: QualityModerationDashboardResponse
  status: 200
}

export type getQualityModerationStatusQualityModerationStatusGetResponse400 = {
  data: void
  status: 400
}

export type getQualityModerationStatusQualityModerationStatusGetResponse401 = {
  data: void
  status: 401
}

export type getQualityModerationStatusQualityModerationStatusGetResponse403 = {
  data: void
  status: 403
}

export type getQualityModerationStatusQualityModerationStatusGetResponse422 = {
  data: void
  status: 422
}

export type getQualityModerationStatusQualityModerationStatusGetResponse500 = {
  data: void
  status: 500
}
    
export type getQualityModerationStatusQualityModerationStatusGetResponseSuccess = (getQualityModerationStatusQualityModerationStatusGetResponse200) & {
  headers: Headers;
};
export type getQualityModerationStatusQualityModerationStatusGetResponseError = (getQualityModerationStatusQualityModerationStatusGetResponse400 | getQualityModerationStatusQualityModerationStatusGetResponse401 | getQualityModerationStatusQualityModerationStatusGetResponse403 | getQualityModerationStatusQualityModerationStatusGetResponse422 | getQualityModerationStatusQualityModerationStatusGetResponse500) & {
  headers: Headers;
};

export type getQualityModerationStatusQualityModerationStatusGetResponse = (getQualityModerationStatusQualityModerationStatusGetResponseSuccess | getQualityModerationStatusQualityModerationStatusGetResponseError)

export const getGetQualityModerationStatusQualityModerationStatusGetUrl = (params?: GetQualityModerationStatusQualityModerationStatusGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/quality-moderation/status?${stringifiedParams}` : `https://flathub.org/api/v2/quality-moderation/status`
}

export const getQualityModerationStatusQualityModerationStatusGet = async (params?: GetQualityModerationStatusQualityModerationStatusGetParams, options?: RequestInit): Promise<getQualityModerationStatusQualityModerationStatusGetResponse> => {
  
  const res = await fetch(getGetQualityModerationStatusQualityModerationStatusGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getQualityModerationStatusQualityModerationStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getQualityModerationStatusQualityModerationStatusGetResponse
}



/**
 * @summary Get Passing Quality Apps
 */
export type getPassingQualityAppsQualityModerationPassingAppsGetResponse200 = {
  data: SimpleQualityModerationResponse
  status: 200
}

export type getPassingQualityAppsQualityModerationPassingAppsGetResponse400 = {
  data: void
  status: 400
}

export type getPassingQualityAppsQualityModerationPassingAppsGetResponse422 = {
  data: void
  status: 422
}

export type getPassingQualityAppsQualityModerationPassingAppsGetResponse500 = {
  data: void
  status: 500
}
    
export type getPassingQualityAppsQualityModerationPassingAppsGetResponseSuccess = (getPassingQualityAppsQualityModerationPassingAppsGetResponse200) & {
  headers: Headers;
};
export type getPassingQualityAppsQualityModerationPassingAppsGetResponseError = (getPassingQualityAppsQualityModerationPassingAppsGetResponse400 | getPassingQualityAppsQualityModerationPassingAppsGetResponse422 | getPassingQualityAppsQualityModerationPassingAppsGetResponse500) & {
  headers: Headers;
};

export type getPassingQualityAppsQualityModerationPassingAppsGetResponse = (getPassingQualityAppsQualityModerationPassingAppsGetResponseSuccess | getPassingQualityAppsQualityModerationPassingAppsGetResponseError)

export const getGetPassingQualityAppsQualityModerationPassingAppsGetUrl = (params?: GetPassingQualityAppsQualityModerationPassingAppsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/quality-moderation/passing-apps?${stringifiedParams}` : `https://flathub.org/api/v2/quality-moderation/passing-apps`
}

export const getPassingQualityAppsQualityModerationPassingAppsGet = async (params?: GetPassingQualityAppsQualityModerationPassingAppsGetParams, options?: RequestInit): Promise<getPassingQualityAppsQualityModerationPassingAppsGetResponse> => {
  
  const res = await fetch(getGetPassingQualityAppsQualityModerationPassingAppsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPassingQualityAppsQualityModerationPassingAppsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPassingQualityAppsQualityModerationPassingAppsGetResponse
}



/**
 * @summary Get App Pick Recommendations
 */
export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse200 = {
  data: AppPickRecommendationsResponse
  status: 200
}

export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse401 = {
  data: void
  status: 401
}

export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse403 = {
  data: void
  status: 403
}

export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse422 = {
  data: void
  status: 422
}

export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse500 = {
  data: void
  status: 500
}
    
export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponseSuccess = (getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse200) & {
  headers: Headers;
};
export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponseError = (getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse401 | getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse403 | getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse422 | getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse500) & {
  headers: Headers;
};

export type getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse = (getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponseSuccess | getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponseError)

export const getGetAppPickRecommendationsQualityModerationAppPickRecommendationsGetUrl = (params?: GetAppPickRecommendationsQualityModerationAppPickRecommendationsGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/quality-moderation/app-pick-recommendations?${stringifiedParams}` : `https://flathub.org/api/v2/quality-moderation/app-pick-recommendations`
}

export const getAppPickRecommendationsQualityModerationAppPickRecommendationsGet = async (params?: GetAppPickRecommendationsQualityModerationAppPickRecommendationsGetParams, options?: RequestInit): Promise<getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse> => {
  
  const res = await fetch(getGetAppPickRecommendationsQualityModerationAppPickRecommendationsGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAppPickRecommendationsQualityModerationAppPickRecommendationsGetResponse
}



/**
 * @summary Get Quality Moderation Stats
 */
export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse200 = {
  data: FailedByGuideline[]
  status: 200
}

export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse401 = {
  data: void
  status: 401
}

export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse403 = {
  data: void
  status: 403
}

export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse500 = {
  data: void
  status: 500
}
    
export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponseSuccess = (getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse200) & {
  headers: Headers;
};
export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponseError = (getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse401 | getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse403 | getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse500) & {
  headers: Headers;
};

export type getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse = (getQualityModerationStatsQualityModerationFailedByGuidelineGetResponseSuccess | getQualityModerationStatsQualityModerationFailedByGuidelineGetResponseError)

export const getGetQualityModerationStatsQualityModerationFailedByGuidelineGetUrl = () => {


  

  return `https://flathub.org/api/v2/quality-moderation/failed-by-guideline`
}

export const getQualityModerationStatsQualityModerationFailedByGuidelineGet = async ( options?: RequestInit): Promise<getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse> => {
  
  const res = await fetch(getGetQualityModerationStatsQualityModerationFailedByGuidelineGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getQualityModerationStatsQualityModerationFailedByGuidelineGetResponse
}



/**
 * @summary Get Quality Moderation For App
 */
export type getQualityModerationForAppQualityModerationAppIdGetResponse200 = {
  data: QualityModerationResponse
  status: 200
}

export type getQualityModerationForAppQualityModerationAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getQualityModerationForAppQualityModerationAppIdGetResponse422 = {
  data: void
  status: 422
}

export type getQualityModerationForAppQualityModerationAppIdGetResponse500 = {
  data: void
  status: 500
}
    
export type getQualityModerationForAppQualityModerationAppIdGetResponseSuccess = (getQualityModerationForAppQualityModerationAppIdGetResponse200) & {
  headers: Headers;
};
export type getQualityModerationForAppQualityModerationAppIdGetResponseError = (getQualityModerationForAppQualityModerationAppIdGetResponse404 | getQualityModerationForAppQualityModerationAppIdGetResponse422 | getQualityModerationForAppQualityModerationAppIdGetResponse500) & {
  headers: Headers;
};

export type getQualityModerationForAppQualityModerationAppIdGetResponse = (getQualityModerationForAppQualityModerationAppIdGetResponseSuccess | getQualityModerationForAppQualityModerationAppIdGetResponseError)

export const getGetQualityModerationForAppQualityModerationAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/quality-moderation/${appId}`
}

export const getQualityModerationForAppQualityModerationAppIdGet = async (appId: string, options?: RequestInit): Promise<getQualityModerationForAppQualityModerationAppIdGetResponse> => {
  
  const res = await fetch(getGetQualityModerationForAppQualityModerationAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getQualityModerationForAppQualityModerationAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getQualityModerationForAppQualityModerationAppIdGetResponse
}



/**
 * @summary Set Quality Moderation For App
 */
export type setQualityModerationForAppQualityModerationAppIdPostResponse200 = {
  data: unknown
  status: 200
}

export type setQualityModerationForAppQualityModerationAppIdPostResponse401 = {
  data: void
  status: 401
}

export type setQualityModerationForAppQualityModerationAppIdPostResponse403 = {
  data: void
  status: 403
}

export type setQualityModerationForAppQualityModerationAppIdPostResponse404 = {
  data: void
  status: 404
}

export type setQualityModerationForAppQualityModerationAppIdPostResponse422 = {
  data: void
  status: 422
}

export type setQualityModerationForAppQualityModerationAppIdPostResponse500 = {
  data: void
  status: 500
}
    
export type setQualityModerationForAppQualityModerationAppIdPostResponseSuccess = (setQualityModerationForAppQualityModerationAppIdPostResponse200) & {
  headers: Headers;
};
export type setQualityModerationForAppQualityModerationAppIdPostResponseError = (setQualityModerationForAppQualityModerationAppIdPostResponse401 | setQualityModerationForAppQualityModerationAppIdPostResponse403 | setQualityModerationForAppQualityModerationAppIdPostResponse404 | setQualityModerationForAppQualityModerationAppIdPostResponse422 | setQualityModerationForAppQualityModerationAppIdPostResponse500) & {
  headers: Headers;
};

export type setQualityModerationForAppQualityModerationAppIdPostResponse = (setQualityModerationForAppQualityModerationAppIdPostResponseSuccess | setQualityModerationForAppQualityModerationAppIdPostResponseError)

export const getSetQualityModerationForAppQualityModerationAppIdPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/quality-moderation/${appId}`
}

export const setQualityModerationForAppQualityModerationAppIdPost = async (appId: string,
    upsertQualityModeration: UpsertQualityModeration, options?: RequestInit): Promise<setQualityModerationForAppQualityModerationAppIdPostResponse> => {
  
  const res = await fetch(getSetQualityModerationForAppQualityModerationAppIdPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      upsertQualityModeration,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setQualityModerationForAppQualityModerationAppIdPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setQualityModerationForAppQualityModerationAppIdPostResponse
}



/**
 * @summary Get Quality Moderation Status For App
 */
export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse200 = {
  data: QualityModerationStatus
  status: 200
}

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse401 = {
  data: void
  status: 401
}

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse403 = {
  data: void
  status: 403
}

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse404 = {
  data: void
  status: 404
}

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse422 = {
  data: void
  status: 422
}

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse500 = {
  data: void
  status: 500
}
    
export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponseSuccess = (getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse200) & {
  headers: Headers;
};
export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponseError = (getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse401 | getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse403 | getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse404 | getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse422 | getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse500) & {
  headers: Headers;
};

export type getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse = (getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponseSuccess | getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponseError)

export const getGetQualityModerationStatusForAppQualityModerationAppIdStatusGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/quality-moderation/${appId}/status`
}

export const getQualityModerationStatusForAppQualityModerationAppIdStatusGet = async (appId: string, options?: RequestInit): Promise<getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse> => {
  
  const res = await fetch(getGetQualityModerationStatusForAppQualityModerationAppIdStatusGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getQualityModerationStatusForAppQualityModerationAppIdStatusGetResponse
}



/**
 * @summary Request Review For App
 */
export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse200 = {
  data: unknown
  status: 200
}

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse401 = {
  data: void
  status: 401
}

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse403 = {
  data: void
  status: 403
}

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse404 = {
  data: void
  status: 404
}

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse422 = {
  data: void
  status: 422
}

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse500 = {
  data: void
  status: 500
}
    
export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponseSuccess = (requestReviewForAppQualityModerationAppIdRequestReviewPostResponse200) & {
  headers: Headers;
};
export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponseError = (requestReviewForAppQualityModerationAppIdRequestReviewPostResponse401 | requestReviewForAppQualityModerationAppIdRequestReviewPostResponse403 | requestReviewForAppQualityModerationAppIdRequestReviewPostResponse404 | requestReviewForAppQualityModerationAppIdRequestReviewPostResponse422 | requestReviewForAppQualityModerationAppIdRequestReviewPostResponse500) & {
  headers: Headers;
};

export type requestReviewForAppQualityModerationAppIdRequestReviewPostResponse = (requestReviewForAppQualityModerationAppIdRequestReviewPostResponseSuccess | requestReviewForAppQualityModerationAppIdRequestReviewPostResponseError)

export const getRequestReviewForAppQualityModerationAppIdRequestReviewPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/quality-moderation/${appId}/request-review`
}

export const requestReviewForAppQualityModerationAppIdRequestReviewPost = async (appId: string, options?: RequestInit): Promise<requestReviewForAppQualityModerationAppIdRequestReviewPostResponse> => {
  
  const res = await fetch(getRequestReviewForAppQualityModerationAppIdRequestReviewPostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: requestReviewForAppQualityModerationAppIdRequestReviewPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as requestReviewForAppQualityModerationAppIdRequestReviewPostResponse
}



/**
 * @summary Delete Review Request For App
 */
export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse200 = {
  data: unknown
  status: 200
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse204 = {
  data: void
  status: 204
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse401 = {
  data: void
  status: 401
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse403 = {
  data: void
  status: 403
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse404 = {
  data: void
  status: 404
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse422 = {
  data: void
  status: 422
}

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse500 = {
  data: void
  status: 500
}
    
export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponseSuccess = (deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse200 | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse204) & {
  headers: Headers;
};
export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponseError = (deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse401 | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse403 | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse404 | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse422 | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse500) & {
  headers: Headers;
};

export type deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse = (deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponseSuccess | deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponseError)

export const getDeleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/quality-moderation/${appId}/request-review`
}

export const deleteReviewRequestForAppQualityModerationAppIdRequestReviewDelete = async (appId: string, options?: RequestInit): Promise<deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse> => {
  
  const res = await fetch(getDeleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteUrl(appId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteReviewRequestForAppQualityModerationAppIdRequestReviewDeleteResponse
}



/**
 * @summary Set Fullscreen App
 */
export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse200 = {
  data: unknown
  status: 200
}

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse401 = {
  data: void
  status: 401
}

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse403 = {
  data: void
  status: 403
}

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse404 = {
  data: void
  status: 404
}

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse422 = {
  data: void
  status: 422
}

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse500 = {
  data: void
  status: 500
}
    
export type setFullscreenAppQualityModerationAppIdFullscreenPostResponseSuccess = (setFullscreenAppQualityModerationAppIdFullscreenPostResponse200) & {
  headers: Headers;
};
export type setFullscreenAppQualityModerationAppIdFullscreenPostResponseError = (setFullscreenAppQualityModerationAppIdFullscreenPostResponse401 | setFullscreenAppQualityModerationAppIdFullscreenPostResponse403 | setFullscreenAppQualityModerationAppIdFullscreenPostResponse404 | setFullscreenAppQualityModerationAppIdFullscreenPostResponse422 | setFullscreenAppQualityModerationAppIdFullscreenPostResponse500) & {
  headers: Headers;
};

export type setFullscreenAppQualityModerationAppIdFullscreenPostResponse = (setFullscreenAppQualityModerationAppIdFullscreenPostResponseSuccess | setFullscreenAppQualityModerationAppIdFullscreenPostResponseError)

export const getSetFullscreenAppQualityModerationAppIdFullscreenPostUrl = (appId: string,
    params: SetFullscreenAppQualityModerationAppIdFullscreenPostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/quality-moderation/${appId}/fullscreen?${stringifiedParams}` : `https://flathub.org/api/v2/quality-moderation/${appId}/fullscreen`
}

export const setFullscreenAppQualityModerationAppIdFullscreenPost = async (appId: string,
    params: SetFullscreenAppQualityModerationAppIdFullscreenPostParams, options?: RequestInit): Promise<setFullscreenAppQualityModerationAppIdFullscreenPostResponse> => {
  
  const res = await fetch(getSetFullscreenAppQualityModerationAppIdFullscreenPostUrl(appId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: setFullscreenAppQualityModerationAppIdFullscreenPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as setFullscreenAppQualityModerationAppIdFullscreenPostResponse
}



/**
 * Get all upload tokens for the given app
 * @summary Get Upload Tokens
 */
export type getUploadTokensUploadTokensAppIdGetResponse200 = {
  data: TokensResponse
  status: 200
}

export type getUploadTokensUploadTokensAppIdGetResponse401 = {
  data: void
  status: 401
}

export type getUploadTokensUploadTokensAppIdGetResponse403 = {
  data: void
  status: 403
}

export type getUploadTokensUploadTokensAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getUploadTokensUploadTokensAppIdGetResponseSuccess = (getUploadTokensUploadTokensAppIdGetResponse200) & {
  headers: Headers;
};
export type getUploadTokensUploadTokensAppIdGetResponseError = (getUploadTokensUploadTokensAppIdGetResponse401 | getUploadTokensUploadTokensAppIdGetResponse403 | getUploadTokensUploadTokensAppIdGetResponse422) & {
  headers: Headers;
};

export type getUploadTokensUploadTokensAppIdGetResponse = (getUploadTokensUploadTokensAppIdGetResponseSuccess | getUploadTokensUploadTokensAppIdGetResponseError)

export const getGetUploadTokensUploadTokensAppIdGetUrl = (appId: string,
    params?: GetUploadTokensUploadTokensAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/upload-tokens/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/upload-tokens/${appId}`
}

export const getUploadTokensUploadTokensAppIdGet = async (appId: string,
    params?: GetUploadTokensUploadTokensAppIdGetParams, options?: RequestInit): Promise<getUploadTokensUploadTokensAppIdGetResponse> => {
  
  const res = await fetch(getGetUploadTokensUploadTokensAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUploadTokensUploadTokensAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUploadTokensUploadTokensAppIdGetResponse
}



/**
 * @summary Create Upload Token
 */
export type createUploadTokenUploadTokensAppIdPostResponse200 = {
  data: NewTokenResponse
  status: 200
}

export type createUploadTokenUploadTokensAppIdPostResponse400 = {
  data: void
  status: 400
}

export type createUploadTokenUploadTokensAppIdPostResponse401 = {
  data: void
  status: 401
}

export type createUploadTokenUploadTokensAppIdPostResponse403 = {
  data: void
  status: 403
}

export type createUploadTokenUploadTokensAppIdPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type createUploadTokenUploadTokensAppIdPostResponse500 = {
  data: void
  status: 500
}
    
export type createUploadTokenUploadTokensAppIdPostResponseSuccess = (createUploadTokenUploadTokensAppIdPostResponse200) & {
  headers: Headers;
};
export type createUploadTokenUploadTokensAppIdPostResponseError = (createUploadTokenUploadTokensAppIdPostResponse400 | createUploadTokenUploadTokensAppIdPostResponse401 | createUploadTokenUploadTokensAppIdPostResponse403 | createUploadTokenUploadTokensAppIdPostResponse422 | createUploadTokenUploadTokensAppIdPostResponse500) & {
  headers: Headers;
};

export type createUploadTokenUploadTokensAppIdPostResponse = (createUploadTokenUploadTokensAppIdPostResponseSuccess | createUploadTokenUploadTokensAppIdPostResponseError)

export const getCreateUploadTokenUploadTokensAppIdPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/upload-tokens/${appId}`
}

export const createUploadTokenUploadTokensAppIdPost = async (appId: string,
    uploadTokenRequest: UploadTokenRequest, options?: RequestInit): Promise<createUploadTokenUploadTokensAppIdPostResponse> => {
  
  const res = await fetch(getCreateUploadTokenUploadTokensAppIdPostUrl(appId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      uploadTokenRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUploadTokenUploadTokensAppIdPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUploadTokenUploadTokensAppIdPostResponse
}



/**
 * @summary Revoke Upload Token
 */
export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse204 = {
  data: void
  status: 204
}

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse401 = {
  data: void
  status: 401
}

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse403 = {
  data: void
  status: 403
}

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse404 = {
  data: void
  status: 404
}

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse500 = {
  data: void
  status: 500
}
    
export type revokeUploadTokenUploadTokensTokenIdRevokePostResponseSuccess = (revokeUploadTokenUploadTokensTokenIdRevokePostResponse204) & {
  headers: Headers;
};
export type revokeUploadTokenUploadTokensTokenIdRevokePostResponseError = (revokeUploadTokenUploadTokensTokenIdRevokePostResponse401 | revokeUploadTokenUploadTokensTokenIdRevokePostResponse403 | revokeUploadTokenUploadTokensTokenIdRevokePostResponse404 | revokeUploadTokenUploadTokensTokenIdRevokePostResponse422 | revokeUploadTokenUploadTokensTokenIdRevokePostResponse500) & {
  headers: Headers;
};

export type revokeUploadTokenUploadTokensTokenIdRevokePostResponse = (revokeUploadTokenUploadTokensTokenIdRevokePostResponseSuccess | revokeUploadTokenUploadTokensTokenIdRevokePostResponseError)

export const getRevokeUploadTokenUploadTokensTokenIdRevokePostUrl = (tokenId: number,) => {


  

  return `https://flathub.org/api/v2/upload-tokens/${tokenId}/revoke`
}

export const revokeUploadTokenUploadTokensTokenIdRevokePost = async (tokenId: number, options?: RequestInit): Promise<revokeUploadTokenUploadTokensTokenIdRevokePostResponse> => {
  
  const res = await fetch(getRevokeUploadTokenUploadTokensTokenIdRevokePostUrl(tokenId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: revokeUploadTokenUploadTokensTokenIdRevokePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as revokeUploadTokenUploadTokensTokenIdRevokePostResponse
}



/**
 * @summary Get Exceptions
 */
export type getExceptionsExceptionsGetResponse200 = {
  data: unknown
  status: 200
}

export type getExceptionsExceptionsGetResponse500 = {
  data: void
  status: 500
}
    
export type getExceptionsExceptionsGetResponseSuccess = (getExceptionsExceptionsGetResponse200) & {
  headers: Headers;
};
export type getExceptionsExceptionsGetResponseError = (getExceptionsExceptionsGetResponse500) & {
  headers: Headers;
};

export type getExceptionsExceptionsGetResponse = (getExceptionsExceptionsGetResponseSuccess | getExceptionsExceptionsGetResponseError)

export const getGetExceptionsExceptionsGetUrl = () => {


  

  return `https://flathub.org/api/v2/exceptions/`
}

export const getExceptionsExceptionsGet = async ( options?: RequestInit): Promise<getExceptionsExceptionsGetResponse> => {
  
  const res = await fetch(getGetExceptionsExceptionsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getExceptionsExceptionsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getExceptionsExceptionsGetResponse
}



/**
 * @summary Get Exceptions For App
 */
export type getExceptionsForAppExceptionsAppIdGetResponse200 = {
  data: unknown
  status: 200
}

export type getExceptionsForAppExceptionsAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getExceptionsForAppExceptionsAppIdGetResponse422 = {
  data: void
  status: 422
}

export type getExceptionsForAppExceptionsAppIdGetResponse500 = {
  data: void
  status: 500
}
    
export type getExceptionsForAppExceptionsAppIdGetResponseSuccess = (getExceptionsForAppExceptionsAppIdGetResponse200) & {
  headers: Headers;
};
export type getExceptionsForAppExceptionsAppIdGetResponseError = (getExceptionsForAppExceptionsAppIdGetResponse404 | getExceptionsForAppExceptionsAppIdGetResponse422 | getExceptionsForAppExceptionsAppIdGetResponse500) & {
  headers: Headers;
};

export type getExceptionsForAppExceptionsAppIdGetResponse = (getExceptionsForAppExceptionsAppIdGetResponseSuccess | getExceptionsForAppExceptionsAppIdGetResponseError)

export const getGetExceptionsForAppExceptionsAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/exceptions/${appId}`
}

export const getExceptionsForAppExceptionsAppIdGet = async (appId: string, options?: RequestInit): Promise<getExceptionsForAppExceptionsAppIdGetResponse> => {
  
  const res = await fetch(getGetExceptionsForAppExceptionsAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getExceptionsForAppExceptionsAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getExceptionsForAppExceptionsAppIdGetResponse
}



/**
 * Return a list of all known users
 * @summary Users
 */
export type usersUsersGetResponse200 = {
  data: FlathubUsersResult
  status: 200
}

export type usersUsersGetResponse400 = {
  data: void
  status: 400
}

export type usersUsersGetResponse401 = {
  data: void
  status: 401
}

export type usersUsersGetResponse403 = {
  data: void
  status: 403
}

export type usersUsersGetResponse422 = {
  data: void
  status: 422
}

export type usersUsersGetResponse500 = {
  data: void
  status: 500
}
    
export type usersUsersGetResponseSuccess = (usersUsersGetResponse200) & {
  headers: Headers;
};
export type usersUsersGetResponseError = (usersUsersGetResponse400 | usersUsersGetResponse401 | usersUsersGetResponse403 | usersUsersGetResponse422 | usersUsersGetResponse500) & {
  headers: Headers;
};

export type usersUsersGetResponse = (usersUsersGetResponseSuccess | usersUsersGetResponseError)

export const getUsersUsersGetUrl = (params?: UsersUsersGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/users?${stringifiedParams}` : `https://flathub.org/api/v2/users`
}

export const usersUsersGet = async (params?: UsersUsersGetParams, options?: RequestInit): Promise<usersUsersGetResponse> => {
  
  const res = await fetch(getUsersUsersGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersUsersGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersUsersGetResponse
}



/**
 * Return a list of all known role names
 * @summary Roles
 */
export type rolesUsersRolesGetResponse200 = {
  data: string[]
  status: 200
}

export type rolesUsersRolesGetResponse401 = {
  data: void
  status: 401
}

export type rolesUsersRolesGetResponse403 = {
  data: void
  status: 403
}

export type rolesUsersRolesGetResponse500 = {
  data: void
  status: 500
}
    
export type rolesUsersRolesGetResponseSuccess = (rolesUsersRolesGetResponse200) & {
  headers: Headers;
};
export type rolesUsersRolesGetResponseError = (rolesUsersRolesGetResponse401 | rolesUsersRolesGetResponse403 | rolesUsersRolesGetResponse500) & {
  headers: Headers;
};

export type rolesUsersRolesGetResponse = (rolesUsersRolesGetResponseSuccess | rolesUsersRolesGetResponseError)

export const getRolesUsersRolesGetUrl = () => {


  

  return `https://flathub.org/api/v2/users/roles`
}

export const rolesUsersRolesGet = async ( options?: RequestInit): Promise<rolesUsersRolesGetResponse> => {
  
  const res = await fetch(getRolesUsersRolesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rolesUsersRolesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rolesUsersRolesGetResponse
}



/**
 * Return the current user
 * @summary User
 */
export type userUsersUserIdGetResponse200 = {
  data: UserResult
  status: 200
}

export type userUsersUserIdGetResponse401 = {
  data: void
  status: 401
}

export type userUsersUserIdGetResponse403 = {
  data: void
  status: 403
}

export type userUsersUserIdGetResponse404 = {
  data: void
  status: 404
}

export type userUsersUserIdGetResponse422 = {
  data: void
  status: 422
}

export type userUsersUserIdGetResponse500 = {
  data: void
  status: 500
}
    
export type userUsersUserIdGetResponseSuccess = (userUsersUserIdGetResponse200) & {
  headers: Headers;
};
export type userUsersUserIdGetResponseError = (userUsersUserIdGetResponse401 | userUsersUserIdGetResponse403 | userUsersUserIdGetResponse404 | userUsersUserIdGetResponse422 | userUsersUserIdGetResponse500) & {
  headers: Headers;
};

export type userUsersUserIdGetResponse = (userUsersUserIdGetResponseSuccess | userUsersUserIdGetResponseError)

export const getUserUsersUserIdGetUrl = (userId: number,) => {


  

  return `https://flathub.org/api/v2/users/${userId}`
}

export const userUsersUserIdGet = async (userId: number, options?: RequestInit): Promise<userUsersUserIdGetResponse> => {
  
  const res = await fetch(getUserUsersUserIdGetUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: userUsersUserIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as userUsersUserIdGetResponse
}



/**
 * Add a role to a user
 * @summary Add User Role
 */
export type addUserRoleUsersUserIdRolePostResponse200 = {
  data: UserResult
  status: 200
}

export type addUserRoleUsersUserIdRolePostResponse401 = {
  data: void
  status: 401
}

export type addUserRoleUsersUserIdRolePostResponse403 = {
  data: void
  status: 403
}

export type addUserRoleUsersUserIdRolePostResponse404 = {
  data: void
  status: 404
}

export type addUserRoleUsersUserIdRolePostResponse422 = {
  data: void
  status: 422
}

export type addUserRoleUsersUserIdRolePostResponse500 = {
  data: void
  status: 500
}
    
export type addUserRoleUsersUserIdRolePostResponseSuccess = (addUserRoleUsersUserIdRolePostResponse200) & {
  headers: Headers;
};
export type addUserRoleUsersUserIdRolePostResponseError = (addUserRoleUsersUserIdRolePostResponse401 | addUserRoleUsersUserIdRolePostResponse403 | addUserRoleUsersUserIdRolePostResponse404 | addUserRoleUsersUserIdRolePostResponse422 | addUserRoleUsersUserIdRolePostResponse500) & {
  headers: Headers;
};

export type addUserRoleUsersUserIdRolePostResponse = (addUserRoleUsersUserIdRolePostResponseSuccess | addUserRoleUsersUserIdRolePostResponseError)

export const getAddUserRoleUsersUserIdRolePostUrl = (userId: number,
    params: AddUserRoleUsersUserIdRolePostParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/users/${userId}/role?${stringifiedParams}` : `https://flathub.org/api/v2/users/${userId}/role`
}

export const addUserRoleUsersUserIdRolePost = async (userId: number,
    params: AddUserRoleUsersUserIdRolePostParams, options?: RequestInit): Promise<addUserRoleUsersUserIdRolePostResponse> => {
  
  const res = await fetch(getAddUserRoleUsersUserIdRolePostUrl(userId,params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addUserRoleUsersUserIdRolePostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addUserRoleUsersUserIdRolePostResponse
}



/**
 * Remove a role from a user
 * @summary Delete User Role
 */
export type deleteUserRoleUsersUserIdRoleDeleteResponse200 = {
  data: UserResult
  status: 200
}

export type deleteUserRoleUsersUserIdRoleDeleteResponse401 = {
  data: void
  status: 401
}

export type deleteUserRoleUsersUserIdRoleDeleteResponse403 = {
  data: void
  status: 403
}

export type deleteUserRoleUsersUserIdRoleDeleteResponse404 = {
  data: void
  status: 404
}

export type deleteUserRoleUsersUserIdRoleDeleteResponse422 = {
  data: void
  status: 422
}

export type deleteUserRoleUsersUserIdRoleDeleteResponse500 = {
  data: void
  status: 500
}
    
export type deleteUserRoleUsersUserIdRoleDeleteResponseSuccess = (deleteUserRoleUsersUserIdRoleDeleteResponse200) & {
  headers: Headers;
};
export type deleteUserRoleUsersUserIdRoleDeleteResponseError = (deleteUserRoleUsersUserIdRoleDeleteResponse401 | deleteUserRoleUsersUserIdRoleDeleteResponse403 | deleteUserRoleUsersUserIdRoleDeleteResponse404 | deleteUserRoleUsersUserIdRoleDeleteResponse422 | deleteUserRoleUsersUserIdRoleDeleteResponse500) & {
  headers: Headers;
};

export type deleteUserRoleUsersUserIdRoleDeleteResponse = (deleteUserRoleUsersUserIdRoleDeleteResponseSuccess | deleteUserRoleUsersUserIdRoleDeleteResponseError)

export const getDeleteUserRoleUsersUserIdRoleDeleteUrl = (userId: number,
    params: DeleteUserRoleUsersUserIdRoleDeleteParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/users/${userId}/role?${stringifiedParams}` : `https://flathub.org/api/v2/users/${userId}/role`
}

export const deleteUserRoleUsersUserIdRoleDelete = async (userId: number,
    params: DeleteUserRoleUsersUserIdRoleDeleteParams, options?: RequestInit): Promise<deleteUserRoleUsersUserIdRoleDeleteResponse> => {
  
  const res = await fetch(getDeleteUserRoleUsersUserIdRoleDeleteUrl(userId,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUserRoleUsersUserIdRoleDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUserRoleUsersUserIdRoleDeleteResponse
}



/**
 * Return all users with a specific role
 * @summary Role Users
 */
export type roleUsersUsersRolesRoleNameGetResponse200 = {
  data: UserResult[]
  status: 200
}

export type roleUsersUsersRolesRoleNameGetResponse401 = {
  data: void
  status: 401
}

export type roleUsersUsersRolesRoleNameGetResponse403 = {
  data: void
  status: 403
}

export type roleUsersUsersRolesRoleNameGetResponse404 = {
  data: void
  status: 404
}

export type roleUsersUsersRolesRoleNameGetResponse422 = {
  data: void
  status: 422
}

export type roleUsersUsersRolesRoleNameGetResponse500 = {
  data: void
  status: 500
}
    
export type roleUsersUsersRolesRoleNameGetResponseSuccess = (roleUsersUsersRolesRoleNameGetResponse200) & {
  headers: Headers;
};
export type roleUsersUsersRolesRoleNameGetResponseError = (roleUsersUsersRolesRoleNameGetResponse401 | roleUsersUsersRolesRoleNameGetResponse403 | roleUsersUsersRolesRoleNameGetResponse404 | roleUsersUsersRolesRoleNameGetResponse422 | roleUsersUsersRolesRoleNameGetResponse500) & {
  headers: Headers;
};

export type roleUsersUsersRolesRoleNameGetResponse = (roleUsersUsersRolesRoleNameGetResponseSuccess | roleUsersUsersRolesRoleNameGetResponseError)

export const getRoleUsersUsersRolesRoleNameGetUrl = (roleName: RoleName,) => {


  

  return `https://flathub.org/api/v2/users/roles/${roleName}`
}

export const roleUsersUsersRolesRoleNameGet = async (roleName: RoleName, options?: RequestInit): Promise<roleUsersUsersRolesRoleNameGetResponse> => {
  
  const res = await fetch(getRoleUsersUsersRolesRoleNameGetUrl(roleName),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: roleUsersUsersRolesRoleNameGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as roleUsersUsersRolesRoleNameGetResponse
}



/**
 * Add an app to a users favorites. The appid is the ID of the app to add.
 * @summary Add To Favorites
 */
export type addToFavoritesFavoritesAppIdAddPostResponse200 = {
  data: unknown
  status: 200
}

export type addToFavoritesFavoritesAppIdAddPostResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type addToFavoritesFavoritesAppIdAddPostResponse500 = {
  data: void
  status: 500
}
    
export type addToFavoritesFavoritesAppIdAddPostResponseSuccess = (addToFavoritesFavoritesAppIdAddPostResponse200) & {
  headers: Headers;
};
export type addToFavoritesFavoritesAppIdAddPostResponseError = (addToFavoritesFavoritesAppIdAddPostResponse422 | addToFavoritesFavoritesAppIdAddPostResponse500) & {
  headers: Headers;
};

export type addToFavoritesFavoritesAppIdAddPostResponse = (addToFavoritesFavoritesAppIdAddPostResponseSuccess | addToFavoritesFavoritesAppIdAddPostResponseError)

export const getAddToFavoritesFavoritesAppIdAddPostUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/favorites/${appId}/add`
}

export const addToFavoritesFavoritesAppIdAddPost = async (appId: string, options?: RequestInit): Promise<addToFavoritesFavoritesAppIdAddPostResponse> => {
  
  const res = await fetch(getAddToFavoritesFavoritesAppIdAddPostUrl(appId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addToFavoritesFavoritesAppIdAddPostResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addToFavoritesFavoritesAppIdAddPostResponse
}



/**
 * Remove an app from a users favorites. The appid is the ID of the app to remove.
 * @summary Remove From Favorites
 */
export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse200 = {
  data: unknown
  status: 200
}

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse422 = {
  data: HTTPValidationError
  status: 422
}

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse500 = {
  data: void
  status: 500
}
    
export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponseSuccess = (removeFromFavoritesFavoritesAppIdRemoveDeleteResponse200) & {
  headers: Headers;
};
export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponseError = (removeFromFavoritesFavoritesAppIdRemoveDeleteResponse422 | removeFromFavoritesFavoritesAppIdRemoveDeleteResponse500) & {
  headers: Headers;
};

export type removeFromFavoritesFavoritesAppIdRemoveDeleteResponse = (removeFromFavoritesFavoritesAppIdRemoveDeleteResponseSuccess | removeFromFavoritesFavoritesAppIdRemoveDeleteResponseError)

export const getRemoveFromFavoritesFavoritesAppIdRemoveDeleteUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/favorites/${appId}/remove`
}

export const removeFromFavoritesFavoritesAppIdRemoveDelete = async (appId: string, options?: RequestInit): Promise<removeFromFavoritesFavoritesAppIdRemoveDeleteResponse> => {
  
  const res = await fetch(getRemoveFromFavoritesFavoritesAppIdRemoveDeleteUrl(appId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeFromFavoritesFavoritesAppIdRemoveDeleteResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeFromFavoritesFavoritesAppIdRemoveDeleteResponse
}



/**
 * Get a list of the users favorite apps.
 * @summary Get Favorites
 */
export type getFavoritesFavoritesGetResponse200 = {
  data: FavoriteApp[]
  status: 200
}
    
export type getFavoritesFavoritesGetResponseSuccess = (getFavoritesFavoritesGetResponse200) & {
  headers: Headers;
};
;

export type getFavoritesFavoritesGetResponse = (getFavoritesFavoritesGetResponseSuccess)

export const getGetFavoritesFavoritesGetUrl = () => {


  

  return `https://flathub.org/api/v2/favorites`
}

export const getFavoritesFavoritesGet = async ( options?: RequestInit): Promise<getFavoritesFavoritesGetResponse> => {
  
  const res = await fetch(getGetFavoritesFavoritesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getFavoritesFavoritesGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getFavoritesFavoritesGetResponse
}



/**
 * @summary Is Favorited
 */
export type isFavoritedFavoritesAppIdGetResponse200 = {
  data: boolean
  status: 200
}

export type isFavoritedFavoritesAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type isFavoritedFavoritesAppIdGetResponseSuccess = (isFavoritedFavoritesAppIdGetResponse200) & {
  headers: Headers;
};
export type isFavoritedFavoritesAppIdGetResponseError = (isFavoritedFavoritesAppIdGetResponse422) & {
  headers: Headers;
};

export type isFavoritedFavoritesAppIdGetResponse = (isFavoritedFavoritesAppIdGetResponseSuccess | isFavoritedFavoritesAppIdGetResponseError)

export const getIsFavoritedFavoritesAppIdGetUrl = (appId: string,) => {


  

  return `https://flathub.org/api/v2/favorites/${appId}`
}

export const isFavoritedFavoritesAppIdGet = async (appId: string, options?: RequestInit): Promise<isFavoritedFavoritesAppIdGetResponse> => {
  
  const res = await fetch(getIsFavoritedFavoritesAppIdGetUrl(appId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: isFavoritedFavoritesAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as isFavoritedFavoritesAppIdGetResponse
}



/**
 * @summary Get Stats
 */
export type getStatsStatsGetResponse200 = {
  data: GetStatsStatsGet200
  status: 200
}

export type getStatsStatsGetResponse404 = {
  data: void
  status: 404
}
    
export type getStatsStatsGetResponseSuccess = (getStatsStatsGetResponse200) & {
  headers: Headers;
};
export type getStatsStatsGetResponseError = (getStatsStatsGetResponse404) & {
  headers: Headers;
};

export type getStatsStatsGetResponse = (getStatsStatsGetResponseSuccess | getStatsStatsGetResponseError)

export const getGetStatsStatsGetUrl = () => {


  

  return `https://flathub.org/api/v2/stats/`
}

export const getStatsStatsGet = async ( options?: RequestInit): Promise<getStatsStatsGetResponse> => {
  
  const res = await fetch(getGetStatsStatsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStatsStatsGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStatsStatsGetResponse
}



/**
 * @summary Get Stats For App
 */
export type getStatsForAppStatsAppIdGetResponse200 = {
  data: GetStatsForAppStatsAppIdGet200
  status: 200
}

export type getStatsForAppStatsAppIdGetResponse404 = {
  data: void
  status: 404
}

export type getStatsForAppStatsAppIdGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getStatsForAppStatsAppIdGetResponseSuccess = (getStatsForAppStatsAppIdGetResponse200) & {
  headers: Headers;
};
export type getStatsForAppStatsAppIdGetResponseError = (getStatsForAppStatsAppIdGetResponse404 | getStatsForAppStatsAppIdGetResponse422) & {
  headers: Headers;
};

export type getStatsForAppStatsAppIdGetResponse = (getStatsForAppStatsAppIdGetResponseSuccess | getStatsForAppStatsAppIdGetResponseError)

export const getGetStatsForAppStatsAppIdGetUrl = (appId: string,
    params?: GetStatsForAppStatsAppIdGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://flathub.org/api/v2/stats/${appId}?${stringifiedParams}` : `https://flathub.org/api/v2/stats/${appId}`
}

export const getStatsForAppStatsAppIdGet = async (appId: string,
    params?: GetStatsForAppStatsAppIdGetParams, options?: RequestInit): Promise<getStatsForAppStatsAppIdGetResponse> => {
  
  const res = await fetch(getGetStatsForAppStatsAppIdGetUrl(appId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getStatsForAppStatsAppIdGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getStatsForAppStatsAppIdGetResponse
}



/**
 * @summary Healthcheck
 */
export type healthcheckStatusGetResponse200 = {
  data: unknown
  status: 200
}
    
export type healthcheckStatusGetResponseSuccess = (healthcheckStatusGetResponse200) & {
  headers: Headers;
};
;

export type healthcheckStatusGetResponse = (healthcheckStatusGetResponseSuccess)

export const getHealthcheckStatusGetUrl = () => {


  

  return `https://flathub.org/api/v2/status`
}

export const healthcheckStatusGet = async ( options?: RequestInit): Promise<healthcheckStatusGetResponse> => {
  
  const res = await fetch(getHealthcheckStatusGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: healthcheckStatusGetResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as healthcheckStatusGetResponse
}
